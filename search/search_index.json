{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion: Range vs. Angle of Projection - Detailed Analysis Introduction: A Journey into Trajectory Welcome to an exploration of projectile motion, a fundamental concept in physics that governs the flight of objects through the air. From the arc of a thrown ball to the trajectory of a rocket, understanding projectile motion allows us to predict and control the paths of countless objects. This presentation dives deep into the underlying principles, practical applications, and computational modeling of this fascinating phenomenon. 1. Theoretical Foundation: Unraveling the Motion Derivation of Governing Equations: A Step-by-Step Approach Let's delve deeper into the derivation. We begin with Newton's second law, \\(\\vec{F} = m\\vec{a}\\) . The only force acting on the projectile is gravity, \\(\\vec{F} = m\\vec{g}\\) , where \\(\\vec{g} = (0, -g)\\) and \\(g \\approx 9.81 \\, \\text{m/s}^2\\) . From this, we get the acceleration vector: \\[\\vec{a} = \\frac{\\vec{F}}{m} = \\vec{g} = (0, -g)\\] This leads to the following differential equations: \\[\\frac{d^2x}{dt^2} = 0\\] \\[\\frac{d^2y}{dt^2} = -g\\] Integrating once with respect to time \\(t\\) , we obtain the velocity components: \\[\\frac{dx}{dt} = v_x(t) = v_{0x} = v_0 \\cos(\\theta)\\] \\[\\frac{dy}{dt} = v_y(t) = v_{0y} - gt = v_0 \\sin(\\theta) - gt\\] Integrating again, we get the position components: \\[x(t) = v_{0x} t = v_0 \\cos(\\theta) t\\] \\[y(t) = v_{0y} t - \\frac{1}{2}gt^2 = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2\\] These are the parametric equations describing the projectile's trajectory. Family of Solutions: Visualizing the Possibilities The parameters \\(v_0\\) and \\(\\theta\\) define a family of parabolic trajectories. Each combination of these values corresponds to a unique path. 2. Analysis of the Range: Maximizing Distance Range Equation: Derivation and Interpretation As derived previously, the range \\(R\\) is given by: \\[R = \\frac{v_0^2}{g} \\sin(2\\theta)\\] Initial Velocity ( \\(v_0\\) ): The range increases quadratically with \\(v_0\\) . Doubling the initial velocity quadruples the range. Launch Angle ( \\(\\theta\\) ): The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at \\(\\theta = 45^\\circ\\) . Gravitational Acceleration ( \\(g\\) ): The range is inversely proportional to \\(g\\) . On a planet with lower gravity, the range would be greater. Python Code Snippets for Projectile Motion Analysis Range vs. Angle Graph import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, g=9.81): theta_rad = np.radians(theta) return (v0**2 / g) * np.sin(2 * theta_rad) def plot_range_vs_angle(v0, g=9.81): angles = np.linspace(0, 90, 100) ranges = projectile_range(v0, angles, g) plt.plot(angles, ranges) plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(f\"Range vs. Angle (v0 = {v0} m/s, g = {g} m/s^2)\") plt.grid(True) plt.savefig(\"range_vs_angle.png\") plt.show() v0 = 25 plot_range_vs_angle(v0) This graph showcases the relationship between launch angle and range, demonstrating the peak at 45 degrees. Projectile Trajectories Graph import numpy as np import matplotlib.pyplot as plt def projectile_trajectory(v0, theta, t, g=9.81): theta_rad = np.radians(theta) x = v0 * np.cos(theta_rad) * t y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 return x, y def plot_trajectories(v0, angles, g=9.81): plt.figure() for theta in angles: time_flight = (2 * v0 * np.sin(np.radians(theta)))/g times = np.linspace(0, time_flight, 100) x, y = projectile_trajectory(v0, theta, times, g) plt.plot(x, y, label=f\"\u03b8 = {theta}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(f\"Projectile Trajectories (v0 = {v0} m/s)\") plt.grid(True) plt.legend() plt.savefig(\"trajectories.png\") plt.show() v0 = 25 plot_trajectories(v0, [30, 45, 60]) These graphs show the different paths of a projectile based on angle change. 3. Practical Applications: Beyond the Textbook Real-World Relevance: From Sports to Space Projectile motion finds applications in various domains, including: Sports: Optimizing the trajectory of balls in golf, baseball, and soccer. Military: Calculating the flight paths of artillery shells and rockets. Engineering: Designing fluid systems, such as water jets and sprinklers. Space Exploration: Predicting the orbits of spacecraft and satellites. 4. Implementation: Computational Modeling Enhancing Realism: Incorporating Complexities To bridge the gap between idealized models and real-world scenarios, we can incorporate factors such as: Air Resistance: Introducing a drag force to account for air friction. Variable Gravity: Modeling the change in gravitational acceleration with altitude. Wind Effects: Simulating the impact of wind on the projectile's path. Terrain Modeling: Accounting for uneven terrain using digital elevation models. Projectile Trajectories with Drag Graph import numpy as np import matplotlib.pyplot as plt def projectile_trajectory_drag(v0, theta, drag_coeff, t_max, dt=0.01, g=9.81): theta_rad = np.radians(theta) vx, vy = v0 * np.cos(theta_rad), v0 * np.sin(theta_rad) x, y = 0, 0 x_coords, y_coords = [x], [y] t = 0 while t < t_max and y >= 0: v = np.sqrt(vx**2 + vy**2) drag_force_x = -drag_coeff * v * vx drag_force_y = -drag_coeff * v * vy ax = drag_force_x ay = -g + drag_force_y vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_coords.append(x) y_coords.append(y) t += dt return x_coords, y_coords def plot_trajectories_drag(v0, angles, drag_coeff=0.01): plt.figure() t_max = 10 for theta in angles: x, y = projectile_trajectory_drag(v0, theta, drag_coeff, t_max) plt.plot(x, y, label=f\"\u03b8 = {theta}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(f\"Projectile Trajectories (v0 = {v0} m/s, Drag = {drag_coeff})\") plt.grid(True) plt.legend() plt.savefig(\"trajectories_drag.png\") plt.show() v0 = 25 plot_trajectories_drag(v0, [30, 45, 60]) These graphs demonstrate the impact of air resistance on projectile trajectories, showcasing the deviation from the ideal parabolic path. Limitations and Improvements: Toward Greater Accuracy Refining the Model: Incorporating Advanced Concepts To further enhance the accuracy of our models, we can consider: Variable Drag: Accounting for changes in drag coefficient with velocity and air density. Spin Effects: Incorporating the Magnus effect, which accounts for the influence of spin on trajectory. Coriolis Effect: Considering the impact of Earth's rotation on long-range projectiles. Numerical Methods: Employing advanced numerical methods, such as Runge-Kutta, for complex simulations. Conclusion: A Deeper Understanding Projectile motion, though seemingly simple, offers a rich tapestry of insights into the fundamental principles of physics. By exploring its theoretical foundations, practical applications, and computational modeling, we gain a deeper understanding of the forces that shape the world around us.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-range-vs-angle-of-projection-detailed-analysis","text":"","title":"Projectile Motion: Range vs. Angle of Projection - Detailed Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#introduction-a-journey-into-trajectory","text":"Welcome to an exploration of projectile motion, a fundamental concept in physics that governs the flight of objects through the air. From the arc of a thrown ball to the trajectory of a rocket, understanding projectile motion allows us to predict and control the paths of countless objects. This presentation dives deep into the underlying principles, practical applications, and computational modeling of this fascinating phenomenon.","title":"Introduction: A Journey into Trajectory"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation-unraveling-the-motion","text":"","title":"1. Theoretical Foundation: Unraveling the Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-governing-equations-a-step-by-step-approach","text":"Let's delve deeper into the derivation. We begin with Newton's second law, \\(\\vec{F} = m\\vec{a}\\) . The only force acting on the projectile is gravity, \\(\\vec{F} = m\\vec{g}\\) , where \\(\\vec{g} = (0, -g)\\) and \\(g \\approx 9.81 \\, \\text{m/s}^2\\) . From this, we get the acceleration vector: \\[\\vec{a} = \\frac{\\vec{F}}{m} = \\vec{g} = (0, -g)\\] This leads to the following differential equations: \\[\\frac{d^2x}{dt^2} = 0\\] \\[\\frac{d^2y}{dt^2} = -g\\] Integrating once with respect to time \\(t\\) , we obtain the velocity components: \\[\\frac{dx}{dt} = v_x(t) = v_{0x} = v_0 \\cos(\\theta)\\] \\[\\frac{dy}{dt} = v_y(t) = v_{0y} - gt = v_0 \\sin(\\theta) - gt\\] Integrating again, we get the position components: \\[x(t) = v_{0x} t = v_0 \\cos(\\theta) t\\] \\[y(t) = v_{0y} t - \\frac{1}{2}gt^2 = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2\\] These are the parametric equations describing the projectile's trajectory.","title":"Derivation of Governing Equations: A Step-by-Step Approach"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions-visualizing-the-possibilities","text":"The parameters \\(v_0\\) and \\(\\theta\\) define a family of parabolic trajectories. Each combination of these values corresponds to a unique path.","title":"Family of Solutions: Visualizing the Possibilities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range-maximizing-distance","text":"","title":"2. Analysis of the Range: Maximizing Distance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation-derivation-and-interpretation","text":"As derived previously, the range \\(R\\) is given by: \\[R = \\frac{v_0^2}{g} \\sin(2\\theta)\\] Initial Velocity ( \\(v_0\\) ): The range increases quadratically with \\(v_0\\) . Doubling the initial velocity quadruples the range. Launch Angle ( \\(\\theta\\) ): The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at \\(\\theta = 45^\\circ\\) . Gravitational Acceleration ( \\(g\\) ): The range is inversely proportional to \\(g\\) . On a planet with lower gravity, the range would be greater.","title":"Range Equation: Derivation and Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-snippets-for-projectile-motion-analysis","text":"","title":"Python Code Snippets for Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-graph","text":"import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, g=9.81): theta_rad = np.radians(theta) return (v0**2 / g) * np.sin(2 * theta_rad) def plot_range_vs_angle(v0, g=9.81): angles = np.linspace(0, 90, 100) ranges = projectile_range(v0, angles, g) plt.plot(angles, ranges) plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(f\"Range vs. Angle (v0 = {v0} m/s, g = {g} m/s^2)\") plt.grid(True) plt.savefig(\"range_vs_angle.png\") plt.show() v0 = 25 plot_range_vs_angle(v0)","title":"Range vs. Angle Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#this-graph-showcases-the-relationship-between-launch-angle-and-range-demonstrating-the-peak-at-45-degrees","text":"","title":"This graph showcases the relationship between launch angle and range, demonstrating the peak at 45 degrees."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-trajectories-graph","text":"import numpy as np import matplotlib.pyplot as plt def projectile_trajectory(v0, theta, t, g=9.81): theta_rad = np.radians(theta) x = v0 * np.cos(theta_rad) * t y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 return x, y def plot_trajectories(v0, angles, g=9.81): plt.figure() for theta in angles: time_flight = (2 * v0 * np.sin(np.radians(theta)))/g times = np.linspace(0, time_flight, 100) x, y = projectile_trajectory(v0, theta, times, g) plt.plot(x, y, label=f\"\u03b8 = {theta}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(f\"Projectile Trajectories (v0 = {v0} m/s)\") plt.grid(True) plt.legend() plt.savefig(\"trajectories.png\") plt.show() v0 = 25 plot_trajectories(v0, [30, 45, 60])","title":"Projectile Trajectories Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#these-graphs-show-the-different-paths-of-a-projectile-based-on-angle-change","text":"","title":"These graphs show the different paths of a projectile based on angle change."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications-beyond-the-textbook","text":"","title":"3. Practical Applications: Beyond the Textbook"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-relevance-from-sports-to-space","text":"Projectile motion finds applications in various domains, including: Sports: Optimizing the trajectory of balls in golf, baseball, and soccer. Military: Calculating the flight paths of artillery shells and rockets. Engineering: Designing fluid systems, such as water jets and sprinklers. Space Exploration: Predicting the orbits of spacecraft and satellites.","title":"Real-World Relevance: From Sports to Space"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-computational-modeling","text":"","title":"4. Implementation: Computational Modeling"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#enhancing-realism-incorporating-complexities","text":"To bridge the gap between idealized models and real-world scenarios, we can incorporate factors such as: Air Resistance: Introducing a drag force to account for air friction. Variable Gravity: Modeling the change in gravitational acceleration with altitude. Wind Effects: Simulating the impact of wind on the projectile's path. Terrain Modeling: Accounting for uneven terrain using digital elevation models.","title":"Enhancing Realism: Incorporating Complexities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-trajectories-with-drag-graph","text":"import numpy as np import matplotlib.pyplot as plt def projectile_trajectory_drag(v0, theta, drag_coeff, t_max, dt=0.01, g=9.81): theta_rad = np.radians(theta) vx, vy = v0 * np.cos(theta_rad), v0 * np.sin(theta_rad) x, y = 0, 0 x_coords, y_coords = [x], [y] t = 0 while t < t_max and y >= 0: v = np.sqrt(vx**2 + vy**2) drag_force_x = -drag_coeff * v * vx drag_force_y = -drag_coeff * v * vy ax = drag_force_x ay = -g + drag_force_y vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_coords.append(x) y_coords.append(y) t += dt return x_coords, y_coords def plot_trajectories_drag(v0, angles, drag_coeff=0.01): plt.figure() t_max = 10 for theta in angles: x, y = projectile_trajectory_drag(v0, theta, drag_coeff, t_max) plt.plot(x, y, label=f\"\u03b8 = {theta}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(f\"Projectile Trajectories (v0 = {v0} m/s, Drag = {drag_coeff})\") plt.grid(True) plt.legend() plt.savefig(\"trajectories_drag.png\") plt.show() v0 = 25 plot_trajectories_drag(v0, [30, 45, 60])","title":"Projectile Trajectories with Drag Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#these-graphs-demonstrate-the-impact-of-air-resistance-on-projectile-trajectories-showcasing-the-deviation-from-the-ideal-parabolic-path","text":"","title":"These graphs demonstrate the impact of air resistance on projectile trajectories, showcasing the deviation from the ideal parabolic path."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-improvements-toward-greater-accuracy","text":"","title":"Limitations and Improvements: Toward Greater Accuracy"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#refining-the-model-incorporating-advanced-concepts","text":"To further enhance the accuracy of our models, we can consider: Variable Drag: Accounting for changes in drag coefficient with velocity and air density. Spin Effects: Incorporating the Magnus effect, which accounts for the influence of spin on trajectory. Coriolis Effect: Considering the impact of Earth's rotation on long-range projectiles. Numerical Methods: Employing advanced numerical methods, such as Runge-Kutta, for complex simulations.","title":"Refining the Model: Incorporating Advanced Concepts"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion-a-deeper-understanding","text":"Projectile motion, though seemingly simple, offers a rich tapestry of insights into the fundamental principles of physics. By exploring its theoretical foundations, practical applications, and computational modeling, we gain a deeper understanding of the forces that shape the world around us.","title":"Conclusion: A Deeper Understanding"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1 Theoretical Foundation The motion of a forced damped pendulum is governed by the following second-order non-linear differential equation: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t)\\) where : \\(\\theta(t)\\) is the angular displacement of the pendulum from the vertical. \\(t\\) is time. \\(b\\) is the damping coefficient (representing energy dissipation). \\(g\\) is the acceleration due to gravity. \\(L\\) is the length of the pendulum. \\(A\\) is the amplitude of the driving force (normalized by mass and length). \\(\\omega\\) is the angular frequency of the driving force. 1.1 Approximate Solutions for Small-Angle Oscillations For small angles, we can use the approximation \\(\\sin\\theta \\approx \\theta\\) . This simplifies the equation to a linear second-order non-homogeneous differential equation: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2\\theta = A\\cos(\\omega t)\\) where \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural angular frequency of the undamped pendulum. The general solution to this equation consists of two parts: the homogeneous solution (transient behavior) and the particular solution (steady-state behavior). Homogeneous Solution: The homogeneous equation is \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2\\theta = 0\\) . The form of the homogeneous solution depends on the discriminant of the characteristic equation \\(r^2 + br + \\omega_0^2 = 0\\) , which is \\(\\Delta = b^2 - 4\\omega_0^2\\) . Overdamped ( \\(b^2 > 4\\omega_0^2\\) ): \\(\\theta_h(t) = C_1e^{r_1t} + C_2e^{r_2t}\\) , where \\(r_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4\\omega_0^2}}{2}\\) are real and negative. The oscillations decay exponentially without oscillating. Critically Damped ( \\(b^2 = 4\\omega_0^2\\) ): \\(\\theta_h(t) = (C_1 + C_2t)e^{-\\frac{b}{2}t}\\) . The oscillations decay as quickly as possible without oscillating. Underdamped ( \\(b^2 < 4\\omega_0^2\\) ): \\(\\theta_h(t) = e^{-\\frac{b}{2}t}(C_1\\cos(\\omega_d t) + C_2\\sin(\\omega_d t)) = C e^{-\\frac{b}{2}t}\\cos(\\omega_d t - \\phi)\\) , where \\(\\omega_d = \\sqrt{\\omega_0^2 - \\frac{b^2}{4}}\\) is the damped angular frequency, and \\(C\\) and \\(\\phi\\) are constants determined by initial conditions. The oscillations decay exponentially with a frequency lower than the natural frequency. This plot shows the angular displacement of the pendulum over time, exhibiting a decaying sinusoidal oscillation as expected for an underdamped system. This phase diagram illustrates the trajectory of the underdamped pendulum in phase space, spiraling towards the equilibrium point (0, 0). Particular Solution (Steady-State): We assume a particular solution of the form \\(\\theta_p(t) = \\Theta\\cos(\\omega t - \\delta)\\) , where \\(\\Theta\\) is the amplitude of the forced oscillations and \\(\\delta\\) is the phase lag relative to the driving force. Substituting this into the linear equation and solving for \\(\\Theta\\) and \\(\\delta\\) yields: \\(\\Theta = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}}\\) \\(\\delta = \\arctan\\left(\\frac{b\\omega}{\\omega_0^2 - \\omega^2}\\right)\\) The general solution for small-angle oscillations is the sum of the homogeneous and particular solutions: \\(\\theta(t) = \\theta_h(t) + \\theta_p(t)\\) . After a sufficiently long time, the transient homogeneous solution decays to zero, and the system settles into the steady-state oscillation described by \\(\\theta_p(t)\\) . 1.2 Resonance Conditions and Energy Implications Resonance occurs when the driving frequency \\(\\omega\\) is close to the natural frequency of the system. In the case of the forced damped pendulum (under the small-angle approximation), the amplitude of the steady-state oscillations \\(\\Theta\\) is maximized when the denominator in the expression for \\(\\Theta\\) is minimized. To find the resonance frequency, we can take the derivative of the denominator squared with respect to \\(\\omega\\) and set it to zero: \\(\\frac{d}{d\\omega}[(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2] = 2(\\omega_0^2 - \\omega^2)(-2\\omega) + 2(b\\omega)b = 0\\) \\(-4\\omega(\\omega_0^2 - \\omega^2) + 2b^2\\omega = 0\\) If \\(\\omega \\neq 0\\) , then \\(-2(\\omega_0^2 - \\omega^2) + b^2 = 0\\) , which gives the resonance frequency \\(\\omega_r\\) : \\(\\omega_r = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\) This resonance frequency is slightly lower than the natural frequency \\(\\omega_0\\) when damping is present. For small damping ( \\(b \\ll \\omega_0\\) ), \\(\\omega_r \\approx \\omega_0\\) . Implications for Energy: At resonance, the driving force is most effectively transferring energy to the pendulum. The energy input from the driving force compensates for the energy dissipated by damping, leading to oscillations with the largest possible amplitude for a given driving amplitude. The power supplied by the driving force is: \\(P_{in}(t) = F_{drive}(t) \\cdot v(t)\\) , where \\(F_{drive}(t) = mA\\cos(\\omega t)\\) (assuming mass \\(m\\) is implicitly included in \\(A\\) ) and \\(v(t) = L\\frac{d\\theta}{dt}\\) . The average power input over a cycle is equal to the average power dissipated by damping, \\(P_{dissipated} = b \\langle (\\frac{d\\theta}{dt})^2 \\rangle\\) . At resonance, the energy transfer is maximized, which can lead to very large amplitudes if damping is small. 2 Analysis of Dynamics The dynamics of the forced damped pendulum are significantly influenced by the damping coefficient ( \\(b\\) ), driving amplitude ( \\(A\\) ), and driving frequency ( \\(\\omega\\) ). 2.1 Influence of Parameters Damping Coefficient ( \\(b\\) ): Higher damping leads to faster decay of transient oscillations. Higher damping reduces the amplitude of steady-state oscillations, especially near resonance. Very high damping can prevent oscillations altogether in the homogeneous case (overdamped). In the forced case, high damping broadens the resonance peak and reduces its height. This plot shows the large amplitude oscillations when the driving frequency is close to the natural frequency of the pendulum. The phase diagram shows a limit cycle, indicating sustained oscillations at the driving frequency. This plot illustrates how increased damping reduces the amplitude of the forced oscillations. The phase diagram shows a smaller limit cycle compared to the resonance case, reflecting the reduced amplitude due to higher damping. Driving Amplitude ( \\(A\\) ): The driving amplitude directly scales the amplitude of the steady-state oscillations in the linear regime (small angles). In the non-linear regime (large angles), increasing the driving amplitude can lead to more complex behaviors, including chaos. Driving Frequency ( \\(\\omega\\) ): The driving frequency determines the frequency of the steady-state oscillations. When \\(\\omega\\) is near the natural frequency \\(\\omega_0\\) , resonance occurs, leading to large amplitude oscillations. For frequencies far from \\(\\omega_0\\) , the amplitude of oscillations is generally smaller. In the non-linear regime, different driving frequencies can excite subharmonic or superharmonic oscillations, as well as chaotic behavior. 2.2 Transition Between Regular and Chaotic Motion The forced damped pendulum is a classic example of a system that can exhibit chaotic behavior. Chaos arises from the non-linearity of the \\(\\sin\\theta\\) term in the equation of motion. The transition to chaos typically occurs as one or more parameters (e.g., driving amplitude, driving frequency) are varied. Routes to Chaos: One common route to chaos in this system is through a sequence of period-doubling bifurcations. As a parameter is increased, the system might oscillate with a period \\(T = \\frac{2\\pi}{\\omega}\\) . At a critical parameter value, this oscillation becomes unstable, and the system transitions to an oscillation with period \\(2T\\) . Further increases in the parameter can lead to oscillations with periods \\(4T, 8T, 16T, ...\\) , eventually leading to chaotic motion with no well-defined period. Characteristics of Chaotic Motion: Sensitivity to Initial Conditions: Small differences in the initial conditions of the pendulum lead to exponentially diverging trajectories in phase space. This is often referred to as the \"butterfly effect.\" Aperiodic Behavior: The motion is irregular and does not repeat in a predictable pattern. Strange Attractors: In phase space, the trajectories of chaotic motion are confined to a bounded region called a strange attractor. These attractors have a complex fractal structure. This plot shows the irregular and non-periodic motion characteristic of a potentially chaotic forced damped pendulum. The phase diagram reveals a complex, swirling pattern, suggesting the presence of a strange attractor. The Poincar\u00e9 section shows a scattering of points forming a complex structure, further indicating chaotic behavior. Physical Interpretations: The transition to chaos in a forced damped pendulum signifies a breakdown of predictable, regular motion. The pendulum's response to the driving force becomes highly sensitive to even tiny perturbations, making long-term predictions impossible. This behavior can be observed in various physical systems and has implications for fields ranging from weather forecasting to the stability of mechanical structures. 3 Practical Applications The forced damped pendulum model has numerous real-world applications, including: Energy Harvesting Devices: Pendulum-based energy harvesters can be designed to resonate with ambient vibrations, converting mechanical energy into electrical energy. Understanding the resonance conditions and the effects of damping is crucial for optimizing the efficiency of these devices. Suspension Bridges: The Tacoma Narrows Bridge collapse in 1940 is a dramatic example of how external periodic forces (wind) can drive a structure into resonance, leading to catastrophic failure. The principles of forced oscillations and damping are essential in the design and analysis of large structures like bridges to prevent such events. Oscillating Circuits (RLC Circuits): The behavior of a driven RLC circuit is mathematically analogous to a forced damped mechanical oscillator. The charge on the capacitor or the current in the inductor oscillates in response to a periodic voltage source. Resonance phenomena in RLC circuits are fundamental to radio tuning and filter design. Mechanical Metronomes: These devices use a pendulum to provide a regular beat for music. The damping ensures that the oscillations decay slowly, and the driving force (often through a clockwork mechanism) maintains a constant amplitude. Seismology: The response of buildings and other structures to seismic waves can be modeled as forced damped oscillations. Understanding the natural frequencies of structures and the frequencies present in earthquakes is crucial for designing earthquake-resistant buildings. Biomechanics (Human Gait): The motion of limbs during walking or running can be approximated as damped oscillations driven by muscle forces. The concepts of resonance and energy efficiency are relevant in understanding human locomotion. Climate Systems: While much more complex, some aspects of climate variability can be conceptualized as oscillations driven by periodic forcing (e.g., solar radiation) and influenced by damping mechanisms (e.g., heat dissipation). 4 Implementation We will now create a computational model of the forced damped pendulum using Python. We will use the scipy.integrate.solve_ivp function to numerically solve the second-order differential equation and matplotlib for visualization. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the parameters of the pendulum L = 1.0 # Length of the pendulum (m) g = 9.81 # Acceleration due to gravity (m/s^2) def pendulum_equation(t, y, b, A, omega): \"\"\" Defines the differential equation for the forced damped pendulum. Args: t (float): Time. y (numpy.ndarray): Array containing the angular displacement (theta) and angular velocity (dtheta/dt). b (float): Damping coefficient. A (float): Driving amplitude. omega (float): Driving frequency. Returns: numpy.ndarray: Array containing the derivatives dtheta/dt and d^2theta/dt^2. \"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] def simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b, A, omega): \"\"\" Simulates the motion of the forced damped pendulum. Args: initial_angle (float): Initial angular displacement (radians). initial_velocity (float): Initial angular velocity (radians/s). t_span (tuple): Time interval of the simulation (start, end). t_eval (numpy.ndarray): Array of time points at which to store the solution. b (float): Damping coefficient. A (float): Driving amplitude. omega (float): Driving frequency. Returns: scipy.integrate.OdeResult: Object containing the solution. \"\"\" initial_conditions = [initial_angle, initial_velocity] solution = solve_ivp(pendulum_equation, t_span, initial_conditions, t_eval=t_eval, args=(b, A, omega), dense_output=True, rtol=1e-8, atol=1e-8) return solution def plot_motion(t, theta, title): \"\"\" Plots the angular displacement as a function of time. Args: t (numpy.ndarray): Time array. theta (numpy.ndarray): Angular displacement array. title (str): Title of the plot. \"\"\" plt.figure(figsize=(10, 6)) plt.plot(t, theta) plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(title) plt.grid(True) plt.show() def plot_phase_diagram(theta, omega_dot, title): \"\"\" Plots the phase diagram (angular velocity vs. angular displacement). Args: theta (numpy.ndarray): Angular displacement array. omega_dot (numpy.ndarray): Angular velocity array. title (str): Title of the plot. \"\"\" plt.figure(figsize=(8, 8)) plt.plot(theta, omega_dot) plt.xlabel(\"Angular Displacement (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(title) plt.grid(True) plt.show() def plot_poincare_section(t, theta, omega_dot, driving_period, title): \"\"\" Plots the Poincar\u00e9 section by sampling points at integer multiples of the driving period. Args: t (numpy.ndarray): Time array. theta (numpy.ndarray): Angular displacement array. omega_dot (numpy.ndarray): Angular velocity array. driving_period (float): Period of the driving force (2*pi/omega). title (str): Title of the plot. \"\"\" poincare_theta = poincare_omega_dot = for i, time in enumerate(t): if np.isclose(time % driving_period, 0.0, atol=1e-3): poincare_theta.append(theta[i]) poincare_omega_dot.append(omega_dot[i]) plt.figure(figsize=(8, 8)) plt.scatter(poincare_theta, poincare_omega_dot, s=5) plt.xlabel(\"Angular Displacement (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(title) plt.grid(True) plt.show() if __name__ == \"__main__\": # Example parameters initial_angle = 0.1 # radians initial_velocity = 0.0 # radians/s t_span = (0, 100) # Simulation time span (seconds) t_eval = np.linspace(t_span[0], t_span[1], 10000) # Case 1: Underdamped, no driving force b1 = 0.1 A1 = 0.0 omega1 = np.sqrt(g / L) # Natural frequency sol1 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b1, A1, omega1) plot_motion(sol1.t, sol1.y[0], \"Underdamped Pendulum (No Driving)\") plot_phase_diagram(sol1.y[0], sol1.y[1], \"Phase Diagram: Underdamped Pendulum (No Driving)\") # Case 2: Driven pendulum near resonance b2 = 0.5 A2 = 0.5 omega2 = np.sqrt(g / L) # Driving at natural frequency sol2 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b2, A2, omega2) plot_motion(sol2.t, sol2.y[0], \"Driven Pendulum Near Resonance\") plot_phase_diagram(sol2.y[0], sol2.y[1], \"Phase Diagram: Driven Pendulum Near Resonance\") # Case 3: Driven pendulum with higher damping b3 = 2.0 A3 = 0.5 omega3 = np.sqrt(g / L) sol3 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b3, A3, omega3) plot_motion(sol3.t, sol3.y[0], \"Driven Pendulum with Higher Damping\") plot_phase_diagram(sol3.y[0], sol3.y[1], \"Phase Diagram: Driven Pendulum with Higher Damping\") # Case 4: Potential for chaotic behavior (higher driving amplitude and different frequency) b4 = 0.2 A4 = 1.2 omega4 = 0.8 * np.sqrt(g / L) sol4 = simulate_pendulum(initial_angle, initial_velocity, (0, 300), np.linspace(0, 300, 30000), b4, A4, omega4) plot_motion(sol4.t, sol4.y[0], \"Potentially Chaotic Driven Pendulum\") plot_phase_diagram(sol4.y[0], sol4.y[1], \"Phase Diagram: Potentially Chaotic Driven Pendulum\") driving_period4 = 2 * np.pi / omega4 plot_poincare_section(sol4.t, sol4.y[0], sol4.y[1], driving_period4, \"Poincar\u00e9 Section: Potentially Chaotic Driven Pendulum\") Python Script for Forced Damped Pendulum Simulation This Python script defines the differential equation for the forced damped pendulum and provides functions to simulate its motion, plot the angular displacement over time, plot the phase diagram, and generate a Poincar\u00e9 section. The if __name__ == \"__main__\": block demonstrates simulations for different parameter sets, including cases with no driving, driving near resonance, higher damping, and parameters that might lead to chaotic behavior. To observe the transition to chaos more systematically, one could vary a parameter (e.g., driving amplitude \\(A\\) ) and observe the changes in the phase diagrams and Poincar\u00e9 sections. For regular periodic motion, the Poincar\u00e9 section will consist of a few discrete points. As the system approaches chaos, the number of points increases, and they can form complex patterns indicative of a strange attractor. Visualizing Behavior Under Various Conditions By running the script with different values for \\(b\\) , \\(A\\) , and \\(\\omega\\) , you can observe the following: Small Damping, No Driving: The pendulum oscillates with a frequency close to its natural frequency, and the amplitude decays slowly. The phase diagram shows a spiral converging to the origin. Driven Near Resonance: The amplitude of oscillations becomes large, especially if damping is small. The phase diagram shows a limit cycle. Higher Damping: The amplitude of oscillations is reduced, and the energy dissipation is more significant. The phase diagram shows a limit cycle with a smaller radius compared to the resonance case. Potential Chaos: For certain parameter values, the motion appears irregular and non-periodic. The phase diagram can show a complex structure, and the Poincar\u00e9 section can reveal a fractal-like pattern, indicating chaotic behavior. 5 Deliverables This document serves as a detailed explanation of the forced damped pendulum. The Python script provided implements the simulations and generates the requested visualizations. 5.1 General Solutions The general solution for the forced damped pendulum in the small-angle approximation involves a transient component that decays over time and a steady-state sinusoidal oscillation driven by the external force. For large angles, analytical general solutions are not typically available, and numerical methods are required to explore the dynamics. 5.2 Graphical Representations The Python script generates the following graphical representations: Time Series Plots: Showing the angular displacement as a function of time for different damping coefficients, driving amplitudes, and driving frequencies. This allows visualization of resonance (large amplitude oscillations) and the effects of damping on the amplitude and decay of oscillations. Phase Diagrams: Plots of angular velocity versus angular displacement. These diagrams provide insights into the system's dynamics, showing trajectories converging to a stable equilibrium point (damped oscillations), closed loops (periodic oscillations), or more complex patterns (chaotic behavior). Poincar\u00e9 Sections: For the potentially chaotic case, the Poincar\u00e9 section is plotted by sampling the state of the pendulum at discrete times corresponding to integer multiples of the driving period. This can reveal the underlying structure of the attractor and help distinguish between periodic and chaotic motion. To further illustrate transitions to chaos, one could generate a bifurcation diagram. This involves plotting a characteristic of the system's long-term behavior (e.g., the amplitude of oscillation or the values of \\(\\theta\\) in the Poincar\u00e9 section) as a function of a control parameter (e.g., the driving amplitude \\(A\\) ). Bifurcation diagrams can clearly show the points at which the system undergoes qualitative changes in its behavior, such as period-doubling bifurcations leading to chaos. Implementing the generation of a full bifurcation diagram would require running multiple simulations for a range of parameter values and analyzing the resulting steady-state behavior. 5.3 Discussion on Limitations and Potential Extensions Limitations of the Model: Idealized Damping: The model assumes viscous damping, where the damping force is proportional to the angular velocity. In reality, damping can be more complex and may depend on other factors. Point Mass Approximation: The pendulum is treated as a point mass concentrated at the end of a massless rod. Real pendulums have mass distributed along their length and may experience more complex dynamics due to their physical dimensions. Rigid Support: The model assumes a rigid support for the pendulum. If the support itself is subject to vibrations or other movements, the dynamics of the system can be significantly different. Small-Angle Approximation: The analytical solutions derived for small angles are only valid when \\(\\theta\\) remains small. For large-amplitude oscillations, the full non-linear equation must be considered. Potential Extensions: Nonlinear Damping: Introducing damping forces that are not linearly proportional to velocity (e.g., quadratic damping) would make the model more realistic for some physical systems. Non-Periodic Driving Forces: Exploring the pendulum's response to non-periodic or stochastic driving forces could provide insights into the behavior of systems under more complex external influences. Parametric Excitation: Investigating cases where parameters of the system (e.g., length \\(L\\) ) are varied periodically could lead to interesting phenomena. Coupled Pendulums: Studying the dynamics of multiple coupled forced damped pendulums can reveal complex collective behaviors and synchronization phenomena. Energy Harvesting Optimization: Developing more sophisticated models that include the energy conversion mechanism could help in designing more efficient energy harvesting devices. Control Systems: Investigating how external control forces can be applied to stabilize or modify the pendulum's motion could have applications in robotics and other fields. By addressing these limitations and exploring potential extensions, the model of the forced damped pendulum can be made more accurate and applicable to a wider range of physical and engineering problems. The transition to chaos and the rich dynamics exhibited by this seemingly simple system continue to be a subject of fascination and research in various scientific disciplines.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the following second-order non-linear differential equation: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t)\\) where : \\(\\theta(t)\\) is the angular displacement of the pendulum from the vertical. \\(t\\) is time. \\(b\\) is the damping coefficient (representing energy dissipation). \\(g\\) is the acceleration due to gravity. \\(L\\) is the length of the pendulum. \\(A\\) is the amplitude of the driving force (normalized by mass and length). \\(\\omega\\) is the angular frequency of the driving force.","title":"1 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-approximate-solutions-for-small-angle-oscillations","text":"For small angles, we can use the approximation \\(\\sin\\theta \\approx \\theta\\) . This simplifies the equation to a linear second-order non-homogeneous differential equation: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2\\theta = A\\cos(\\omega t)\\) where \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural angular frequency of the undamped pendulum. The general solution to this equation consists of two parts: the homogeneous solution (transient behavior) and the particular solution (steady-state behavior). Homogeneous Solution: The homogeneous equation is \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2\\theta = 0\\) . The form of the homogeneous solution depends on the discriminant of the characteristic equation \\(r^2 + br + \\omega_0^2 = 0\\) , which is \\(\\Delta = b^2 - 4\\omega_0^2\\) . Overdamped ( \\(b^2 > 4\\omega_0^2\\) ): \\(\\theta_h(t) = C_1e^{r_1t} + C_2e^{r_2t}\\) , where \\(r_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4\\omega_0^2}}{2}\\) are real and negative. The oscillations decay exponentially without oscillating. Critically Damped ( \\(b^2 = 4\\omega_0^2\\) ): \\(\\theta_h(t) = (C_1 + C_2t)e^{-\\frac{b}{2}t}\\) . The oscillations decay as quickly as possible without oscillating. Underdamped ( \\(b^2 < 4\\omega_0^2\\) ): \\(\\theta_h(t) = e^{-\\frac{b}{2}t}(C_1\\cos(\\omega_d t) + C_2\\sin(\\omega_d t)) = C e^{-\\frac{b}{2}t}\\cos(\\omega_d t - \\phi)\\) , where \\(\\omega_d = \\sqrt{\\omega_0^2 - \\frac{b^2}{4}}\\) is the damped angular frequency, and \\(C\\) and \\(\\phi\\) are constants determined by initial conditions. The oscillations decay exponentially with a frequency lower than the natural frequency. This plot shows the angular displacement of the pendulum over time, exhibiting a decaying sinusoidal oscillation as expected for an underdamped system. This phase diagram illustrates the trajectory of the underdamped pendulum in phase space, spiraling towards the equilibrium point (0, 0). Particular Solution (Steady-State): We assume a particular solution of the form \\(\\theta_p(t) = \\Theta\\cos(\\omega t - \\delta)\\) , where \\(\\Theta\\) is the amplitude of the forced oscillations and \\(\\delta\\) is the phase lag relative to the driving force. Substituting this into the linear equation and solving for \\(\\Theta\\) and \\(\\delta\\) yields: \\(\\Theta = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}}\\) \\(\\delta = \\arctan\\left(\\frac{b\\omega}{\\omega_0^2 - \\omega^2}\\right)\\) The general solution for small-angle oscillations is the sum of the homogeneous and particular solutions: \\(\\theta(t) = \\theta_h(t) + \\theta_p(t)\\) . After a sufficiently long time, the transient homogeneous solution decays to zero, and the system settles into the steady-state oscillation described by \\(\\theta_p(t)\\) .","title":"1.1 Approximate Solutions for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-resonance-conditions-and-energy-implications","text":"Resonance occurs when the driving frequency \\(\\omega\\) is close to the natural frequency of the system. In the case of the forced damped pendulum (under the small-angle approximation), the amplitude of the steady-state oscillations \\(\\Theta\\) is maximized when the denominator in the expression for \\(\\Theta\\) is minimized. To find the resonance frequency, we can take the derivative of the denominator squared with respect to \\(\\omega\\) and set it to zero: \\(\\frac{d}{d\\omega}[(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2] = 2(\\omega_0^2 - \\omega^2)(-2\\omega) + 2(b\\omega)b = 0\\) \\(-4\\omega(\\omega_0^2 - \\omega^2) + 2b^2\\omega = 0\\) If \\(\\omega \\neq 0\\) , then \\(-2(\\omega_0^2 - \\omega^2) + b^2 = 0\\) , which gives the resonance frequency \\(\\omega_r\\) : \\(\\omega_r = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\) This resonance frequency is slightly lower than the natural frequency \\(\\omega_0\\) when damping is present. For small damping ( \\(b \\ll \\omega_0\\) ), \\(\\omega_r \\approx \\omega_0\\) . Implications for Energy: At resonance, the driving force is most effectively transferring energy to the pendulum. The energy input from the driving force compensates for the energy dissipated by damping, leading to oscillations with the largest possible amplitude for a given driving amplitude. The power supplied by the driving force is: \\(P_{in}(t) = F_{drive}(t) \\cdot v(t)\\) , where \\(F_{drive}(t) = mA\\cos(\\omega t)\\) (assuming mass \\(m\\) is implicitly included in \\(A\\) ) and \\(v(t) = L\\frac{d\\theta}{dt}\\) . The average power input over a cycle is equal to the average power dissipated by damping, \\(P_{dissipated} = b \\langle (\\frac{d\\theta}{dt})^2 \\rangle\\) . At resonance, the energy transfer is maximized, which can lead to very large amplitudes if damping is small.","title":"1.2 Resonance Conditions and Energy Implications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The dynamics of the forced damped pendulum are significantly influenced by the damping coefficient ( \\(b\\) ), driving amplitude ( \\(A\\) ), and driving frequency ( \\(\\omega\\) ).","title":"2 Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-influence-of-parameters","text":"Damping Coefficient ( \\(b\\) ): Higher damping leads to faster decay of transient oscillations. Higher damping reduces the amplitude of steady-state oscillations, especially near resonance. Very high damping can prevent oscillations altogether in the homogeneous case (overdamped). In the forced case, high damping broadens the resonance peak and reduces its height. This plot shows the large amplitude oscillations when the driving frequency is close to the natural frequency of the pendulum. The phase diagram shows a limit cycle, indicating sustained oscillations at the driving frequency. This plot illustrates how increased damping reduces the amplitude of the forced oscillations. The phase diagram shows a smaller limit cycle compared to the resonance case, reflecting the reduced amplitude due to higher damping. Driving Amplitude ( \\(A\\) ): The driving amplitude directly scales the amplitude of the steady-state oscillations in the linear regime (small angles). In the non-linear regime (large angles), increasing the driving amplitude can lead to more complex behaviors, including chaos. Driving Frequency ( \\(\\omega\\) ): The driving frequency determines the frequency of the steady-state oscillations. When \\(\\omega\\) is near the natural frequency \\(\\omega_0\\) , resonance occurs, leading to large amplitude oscillations. For frequencies far from \\(\\omega_0\\) , the amplitude of oscillations is generally smaller. In the non-linear regime, different driving frequencies can excite subharmonic or superharmonic oscillations, as well as chaotic behavior.","title":"2.1 Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-transition-between-regular-and-chaotic-motion","text":"The forced damped pendulum is a classic example of a system that can exhibit chaotic behavior. Chaos arises from the non-linearity of the \\(\\sin\\theta\\) term in the equation of motion. The transition to chaos typically occurs as one or more parameters (e.g., driving amplitude, driving frequency) are varied. Routes to Chaos: One common route to chaos in this system is through a sequence of period-doubling bifurcations. As a parameter is increased, the system might oscillate with a period \\(T = \\frac{2\\pi}{\\omega}\\) . At a critical parameter value, this oscillation becomes unstable, and the system transitions to an oscillation with period \\(2T\\) . Further increases in the parameter can lead to oscillations with periods \\(4T, 8T, 16T, ...\\) , eventually leading to chaotic motion with no well-defined period. Characteristics of Chaotic Motion: Sensitivity to Initial Conditions: Small differences in the initial conditions of the pendulum lead to exponentially diverging trajectories in phase space. This is often referred to as the \"butterfly effect.\" Aperiodic Behavior: The motion is irregular and does not repeat in a predictable pattern. Strange Attractors: In phase space, the trajectories of chaotic motion are confined to a bounded region called a strange attractor. These attractors have a complex fractal structure. This plot shows the irregular and non-periodic motion characteristic of a potentially chaotic forced damped pendulum. The phase diagram reveals a complex, swirling pattern, suggesting the presence of a strange attractor. The Poincar\u00e9 section shows a scattering of points forming a complex structure, further indicating chaotic behavior. Physical Interpretations: The transition to chaos in a forced damped pendulum signifies a breakdown of predictable, regular motion. The pendulum's response to the driving force becomes highly sensitive to even tiny perturbations, making long-term predictions impossible. This behavior can be observed in various physical systems and has implications for fields ranging from weather forecasting to the stability of mechanical structures.","title":"2.2 Transition Between Regular and Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model has numerous real-world applications, including: Energy Harvesting Devices: Pendulum-based energy harvesters can be designed to resonate with ambient vibrations, converting mechanical energy into electrical energy. Understanding the resonance conditions and the effects of damping is crucial for optimizing the efficiency of these devices. Suspension Bridges: The Tacoma Narrows Bridge collapse in 1940 is a dramatic example of how external periodic forces (wind) can drive a structure into resonance, leading to catastrophic failure. The principles of forced oscillations and damping are essential in the design and analysis of large structures like bridges to prevent such events. Oscillating Circuits (RLC Circuits): The behavior of a driven RLC circuit is mathematically analogous to a forced damped mechanical oscillator. The charge on the capacitor or the current in the inductor oscillates in response to a periodic voltage source. Resonance phenomena in RLC circuits are fundamental to radio tuning and filter design. Mechanical Metronomes: These devices use a pendulum to provide a regular beat for music. The damping ensures that the oscillations decay slowly, and the driving force (often through a clockwork mechanism) maintains a constant amplitude. Seismology: The response of buildings and other structures to seismic waves can be modeled as forced damped oscillations. Understanding the natural frequencies of structures and the frequencies present in earthquakes is crucial for designing earthquake-resistant buildings. Biomechanics (Human Gait): The motion of limbs during walking or running can be approximated as damped oscillations driven by muscle forces. The concepts of resonance and energy efficiency are relevant in understanding human locomotion. Climate Systems: While much more complex, some aspects of climate variability can be conceptualized as oscillations driven by periodic forcing (e.g., solar radiation) and influenced by damping mechanisms (e.g., heat dissipation).","title":"3 Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"We will now create a computational model of the forced damped pendulum using Python. We will use the scipy.integrate.solve_ivp function to numerically solve the second-order differential equation and matplotlib for visualization. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the parameters of the pendulum L = 1.0 # Length of the pendulum (m) g = 9.81 # Acceleration due to gravity (m/s^2) def pendulum_equation(t, y, b, A, omega): \"\"\" Defines the differential equation for the forced damped pendulum. Args: t (float): Time. y (numpy.ndarray): Array containing the angular displacement (theta) and angular velocity (dtheta/dt). b (float): Damping coefficient. A (float): Driving amplitude. omega (float): Driving frequency. Returns: numpy.ndarray: Array containing the derivatives dtheta/dt and d^2theta/dt^2. \"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] def simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b, A, omega): \"\"\" Simulates the motion of the forced damped pendulum. Args: initial_angle (float): Initial angular displacement (radians). initial_velocity (float): Initial angular velocity (radians/s). t_span (tuple): Time interval of the simulation (start, end). t_eval (numpy.ndarray): Array of time points at which to store the solution. b (float): Damping coefficient. A (float): Driving amplitude. omega (float): Driving frequency. Returns: scipy.integrate.OdeResult: Object containing the solution. \"\"\" initial_conditions = [initial_angle, initial_velocity] solution = solve_ivp(pendulum_equation, t_span, initial_conditions, t_eval=t_eval, args=(b, A, omega), dense_output=True, rtol=1e-8, atol=1e-8) return solution def plot_motion(t, theta, title): \"\"\" Plots the angular displacement as a function of time. Args: t (numpy.ndarray): Time array. theta (numpy.ndarray): Angular displacement array. title (str): Title of the plot. \"\"\" plt.figure(figsize=(10, 6)) plt.plot(t, theta) plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(title) plt.grid(True) plt.show() def plot_phase_diagram(theta, omega_dot, title): \"\"\" Plots the phase diagram (angular velocity vs. angular displacement). Args: theta (numpy.ndarray): Angular displacement array. omega_dot (numpy.ndarray): Angular velocity array. title (str): Title of the plot. \"\"\" plt.figure(figsize=(8, 8)) plt.plot(theta, omega_dot) plt.xlabel(\"Angular Displacement (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(title) plt.grid(True) plt.show() def plot_poincare_section(t, theta, omega_dot, driving_period, title): \"\"\" Plots the Poincar\u00e9 section by sampling points at integer multiples of the driving period. Args: t (numpy.ndarray): Time array. theta (numpy.ndarray): Angular displacement array. omega_dot (numpy.ndarray): Angular velocity array. driving_period (float): Period of the driving force (2*pi/omega). title (str): Title of the plot. \"\"\" poincare_theta = poincare_omega_dot = for i, time in enumerate(t): if np.isclose(time % driving_period, 0.0, atol=1e-3): poincare_theta.append(theta[i]) poincare_omega_dot.append(omega_dot[i]) plt.figure(figsize=(8, 8)) plt.scatter(poincare_theta, poincare_omega_dot, s=5) plt.xlabel(\"Angular Displacement (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(title) plt.grid(True) plt.show() if __name__ == \"__main__\": # Example parameters initial_angle = 0.1 # radians initial_velocity = 0.0 # radians/s t_span = (0, 100) # Simulation time span (seconds) t_eval = np.linspace(t_span[0], t_span[1], 10000) # Case 1: Underdamped, no driving force b1 = 0.1 A1 = 0.0 omega1 = np.sqrt(g / L) # Natural frequency sol1 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b1, A1, omega1) plot_motion(sol1.t, sol1.y[0], \"Underdamped Pendulum (No Driving)\") plot_phase_diagram(sol1.y[0], sol1.y[1], \"Phase Diagram: Underdamped Pendulum (No Driving)\") # Case 2: Driven pendulum near resonance b2 = 0.5 A2 = 0.5 omega2 = np.sqrt(g / L) # Driving at natural frequency sol2 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b2, A2, omega2) plot_motion(sol2.t, sol2.y[0], \"Driven Pendulum Near Resonance\") plot_phase_diagram(sol2.y[0], sol2.y[1], \"Phase Diagram: Driven Pendulum Near Resonance\") # Case 3: Driven pendulum with higher damping b3 = 2.0 A3 = 0.5 omega3 = np.sqrt(g / L) sol3 = simulate_pendulum(initial_angle, initial_velocity, t_span, t_eval, b3, A3, omega3) plot_motion(sol3.t, sol3.y[0], \"Driven Pendulum with Higher Damping\") plot_phase_diagram(sol3.y[0], sol3.y[1], \"Phase Diagram: Driven Pendulum with Higher Damping\") # Case 4: Potential for chaotic behavior (higher driving amplitude and different frequency) b4 = 0.2 A4 = 1.2 omega4 = 0.8 * np.sqrt(g / L) sol4 = simulate_pendulum(initial_angle, initial_velocity, (0, 300), np.linspace(0, 300, 30000), b4, A4, omega4) plot_motion(sol4.t, sol4.y[0], \"Potentially Chaotic Driven Pendulum\") plot_phase_diagram(sol4.y[0], sol4.y[1], \"Phase Diagram: Potentially Chaotic Driven Pendulum\") driving_period4 = 2 * np.pi / omega4 plot_poincare_section(sol4.t, sol4.y[0], sol4.y[1], driving_period4, \"Poincar\u00e9 Section: Potentially Chaotic Driven Pendulum\")","title":"4 Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-script-for-forced-damped-pendulum-simulation","text":"This Python script defines the differential equation for the forced damped pendulum and provides functions to simulate its motion, plot the angular displacement over time, plot the phase diagram, and generate a Poincar\u00e9 section. The if __name__ == \"__main__\": block demonstrates simulations for different parameter sets, including cases with no driving, driving near resonance, higher damping, and parameters that might lead to chaotic behavior. To observe the transition to chaos more systematically, one could vary a parameter (e.g., driving amplitude \\(A\\) ) and observe the changes in the phase diagrams and Poincar\u00e9 sections. For regular periodic motion, the Poincar\u00e9 section will consist of a few discrete points. As the system approaches chaos, the number of points increases, and they can form complex patterns indicative of a strange attractor.","title":"Python Script for Forced Damped Pendulum Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualizing-behavior-under-various-conditions","text":"By running the script with different values for \\(b\\) , \\(A\\) , and \\(\\omega\\) , you can observe the following: Small Damping, No Driving: The pendulum oscillates with a frequency close to its natural frequency, and the amplitude decays slowly. The phase diagram shows a spiral converging to the origin. Driven Near Resonance: The amplitude of oscillations becomes large, especially if damping is small. The phase diagram shows a limit cycle. Higher Damping: The amplitude of oscillations is reduced, and the energy dissipation is more significant. The phase diagram shows a limit cycle with a smaller radius compared to the resonance case. Potential Chaos: For certain parameter values, the motion appears irregular and non-periodic. The phase diagram can show a complex structure, and the Poincar\u00e9 section can reveal a fractal-like pattern, indicating chaotic behavior.","title":"Visualizing Behavior Under Various Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-deliverables","text":"This document serves as a detailed explanation of the forced damped pendulum. The Python script provided implements the simulations and generates the requested visualizations.","title":"5 Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-general-solutions","text":"The general solution for the forced damped pendulum in the small-angle approximation involves a transient component that decays over time and a steady-state sinusoidal oscillation driven by the external force. For large angles, analytical general solutions are not typically available, and numerical methods are required to explore the dynamics.","title":"5.1 General Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#52-graphical-representations","text":"The Python script generates the following graphical representations: Time Series Plots: Showing the angular displacement as a function of time for different damping coefficients, driving amplitudes, and driving frequencies. This allows visualization of resonance (large amplitude oscillations) and the effects of damping on the amplitude and decay of oscillations. Phase Diagrams: Plots of angular velocity versus angular displacement. These diagrams provide insights into the system's dynamics, showing trajectories converging to a stable equilibrium point (damped oscillations), closed loops (periodic oscillations), or more complex patterns (chaotic behavior). Poincar\u00e9 Sections: For the potentially chaotic case, the Poincar\u00e9 section is plotted by sampling the state of the pendulum at discrete times corresponding to integer multiples of the driving period. This can reveal the underlying structure of the attractor and help distinguish between periodic and chaotic motion. To further illustrate transitions to chaos, one could generate a bifurcation diagram. This involves plotting a characteristic of the system's long-term behavior (e.g., the amplitude of oscillation or the values of \\(\\theta\\) in the Poincar\u00e9 section) as a function of a control parameter (e.g., the driving amplitude \\(A\\) ). Bifurcation diagrams can clearly show the points at which the system undergoes qualitative changes in its behavior, such as period-doubling bifurcations leading to chaos. Implementing the generation of a full bifurcation diagram would require running multiple simulations for a range of parameter values and analyzing the resulting steady-state behavior.","title":"5.2 Graphical Representations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#53-discussion-on-limitations-and-potential-extensions","text":"","title":"5.3 Discussion on Limitations and Potential Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations-of-the-model","text":"Idealized Damping: The model assumes viscous damping, where the damping force is proportional to the angular velocity. In reality, damping can be more complex and may depend on other factors. Point Mass Approximation: The pendulum is treated as a point mass concentrated at the end of a massless rod. Real pendulums have mass distributed along their length and may experience more complex dynamics due to their physical dimensions. Rigid Support: The model assumes a rigid support for the pendulum. If the support itself is subject to vibrations or other movements, the dynamics of the system can be significantly different. Small-Angle Approximation: The analytical solutions derived for small angles are only valid when \\(\\theta\\) remains small. For large-amplitude oscillations, the full non-linear equation must be considered.","title":"Limitations of the Model:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#potential-extensions","text":"Nonlinear Damping: Introducing damping forces that are not linearly proportional to velocity (e.g., quadratic damping) would make the model more realistic for some physical systems. Non-Periodic Driving Forces: Exploring the pendulum's response to non-periodic or stochastic driving forces could provide insights into the behavior of systems under more complex external influences. Parametric Excitation: Investigating cases where parameters of the system (e.g., length \\(L\\) ) are varied periodically could lead to interesting phenomena. Coupled Pendulums: Studying the dynamics of multiple coupled forced damped pendulums can reveal complex collective behaviors and synchronization phenomena. Energy Harvesting Optimization: Developing more sophisticated models that include the energy conversion mechanism could help in designing more efficient energy harvesting devices. Control Systems: Investigating how external control forces can be applied to stabilize or modify the pendulum's motion could have applications in robotics and other fields. By addressing these limitations and exploring potential extensions, the model of the forced damped pendulum can be made more accurate and applicable to a wider range of physical and engineering problems. The transition to chaos and the rich dynamics exhibited by this seemingly simple system continue to be a subject of fascination and research in various scientific disciplines.","title":"Potential Extensions:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Task 1. Derivation of the Relationship for Circular Orbits Consider an object of mass \\(m\\) (e.g., a planet or a satellite) orbiting a much larger object of mass \\(M\\) (e.g., a star or a planet) in a circular orbit of radius \\(r\\) with an orbital period \\(T\\) . The gravitational force between the two objects provides the centripetal force required for the circular motion. According to Newton's Law of Universal Gravitation , the gravitational force \\(F_g\\) is given by: \\[ F_g = G \\frac{Mm}{r^2} \\] where \\(G\\) is the gravitational constant. The centripetal force \\(F_c\\) required to keep the object of mass \\(m\\) moving in a circle of radius \\(r\\) with a speed \\(v\\) is given by: \\[ F_c = \\frac{mv^2}{r} \\] For a stable circular orbit, the gravitational force must equal the centripetal force: \\[ G \\frac{Mm}{r^2} = \\frac{mv^2}{r} \\] We can cancel the mass of the orbiting object \\(m\\) from both sides: \\[ G \\frac{M}{r^2} = \\frac{v^2}{r} \\] The speed \\(v\\) of the orbiting object is related to the orbital radius \\(r\\) and the orbital period \\(T\\) by the formula: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this expression for \\(v\\) into the equation above: \\[ G \\frac{M}{r^2} = \\frac{(2\\pi r / T)^2}{r} \\] Simplify the equation: \\[ G \\frac{M}{r^2} = \\frac{4\\pi^2 r^2}{T^2 r} \\] \\[ G \\frac{M}{r^2} = \\frac{4\\pi^2 r}{T^2} \\] Now, rearrange the equation to solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] This equation shows that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) , with the constant of proportionality being \\(\\frac{4\\pi^2}{GM}\\) . This is Kepler's Third Law for circular orbits. 2. Implications for Astronomy Kepler's Third Law has several crucial implications for astronomy: Determining the Mass of a Central Body: If we know the orbital period \\(T\\) and the orbital radius \\(r\\) of an object orbiting a central body, we can calculate the mass \\(M\\) of the central body using the rearranged formula: $$ M = \\frac{4\\pi^2 r^3}{GT^2} $$ This is how the masses of stars, planets, and even black holes can be estimated by observing the orbits of their satellites or companion stars. Predicting Orbital Periods and Radii: Conversely, if we know the mass of the central body and either the orbital period or the orbital radius of an orbiting object, we can predict the other quantity. This is essential for planning satellite missions and understanding the dynamics of planetary systems. Understanding Planetary Systems: Kepler's Third Law provides a fundamental framework for understanding the structure and evolution of planetary systems. The consistent relationship between orbital periods and radii across different planets in a system supports the idea of a common formation mechanism. 3. Real-world Examples Let's consider two examples: the Moon orbiting the Earth and the Earth orbiting the Sun. The Moon Orbiting the Earth: Orbital Period of the Moon ( \\(T_{\\text{Moon}}\\) ): \\(\\approx 27.3\\) days \\(\\approx 27.3 \\times 24 \\times 3600\\) seconds \\(\\approx 2.36 \\times 10^6\\) s Average orbital radius of the Moon ( \\(r_{\\text{Moon}}\\) ): \\(\\approx 384,400\\) km \\(\\approx 3.844 \\times 10^8\\) m Mass of the Earth ( \\(M_{\\text{Earth}}\\) ): \\(\\approx 5.972 \\times 10^{24}\\) kg Gravitational constant ( \\(G\\) ): \\(\\approx 6.674 \\times 10^{-11}\\) N\u00b7m\u00b2/kg\u00b2 Let's verify Kepler's Third Law using these values. Calculate \\(\\frac{4\\pi^2 r_{\\text{Moon}}^3}{GM_{\\text{Earth}}}\\) : \\[ \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})} \\approx \\frac{4 \\times (3.14159)^2 \\times 5.66 \\times 10^{25}}{3.985 \\times 10^{14}} \\approx 5.62 \\times 10^{12} \\, \\text{s}^2 \\] Now, let's calculate \\(T_{\\text{Moon}}^2\\) : \\[ (2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12} \\, \\text{s}^2 \\] The calculated value from Kepler's Third Law is very close to the square of the Moon's orbital period, confirming the law. The Earth Orbiting the Sun: Orbital Period of the Earth ( \\(T_{\\text{Earth}}\\) ): \\(\\approx 365.25\\) days \\(\\approx 365.25 \\times 24 \\times 3600\\) seconds \\(\\approx 3.156 \\times 10^7\\) s Average orbital radius of the Earth ( \\(r_{\\text{Earth}}\\) ): \\(\\approx 1.496 \\times 10^{11}\\) m Mass of the Sun ( \\(M_{\\text{Sun}}\\) ): \\(\\approx 1.989 \\times 10^{30}\\) kg Calculate \\(\\frac{4\\pi^2 r_{\\text{Earth}}^3}{GM_{\\text{Sun}}}\\) : \\[ \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.674 \\times 10^{-11})(1.989 \\times 10^{30})} \\approx \\frac{4 \\times (3.14159)^2 \\times 3.348 \\times 10^{33}}{1.327 \\times 10^{20}} \\approx 1.00 \\times 10^{15} \\, \\text{s}^2 \\] Now, let's calculate \\(T_{\\text{Earth}}^2\\) : \\[ (3.156 \\times 10^7)^2 \\approx 9.96 \\times 10^{14} \\, \\text{s}^2 \\] Again, the calculated value is very close to the square of the Earth's orbital period, validating Kepler's Third Law. 4. Computational Model We can create a simplified computational model using Python to simulate circular orbits and observe the relationship between orbital period and radius. Below is an example Python script: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (N\u00b7m\u00b2/kg\u00b2) M = 1.989 * 10**30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(r): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Radii for the curve radii = np.linspace(1e10, 5e12, 100) # in meters T_squared = (orbital_period(radii))**2 r_cubed = radii**3 # Planetary data (semi-major axis in meters, orbital period in seconds) planets = { \"Mercury\": (5.79e10, 7.6e6), \"Venus\": (1.082e11, 1.94e7), \"Earth\": (1.496e11, 3.156e7), \"Mars\": (2.279e11, 5.93e7), \"Jupiter\": (7.785e11, 3.74e8) } # Prepare planet data for plotting planet_r_cubed = [r**3 for r, T in planets.values()] planet_T_squared = [T**2 for r, T in planets.values()] # Plot T^2 vs r^3 on a log-log scale plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=\"T\u00b2 vs r\u00b3 (Kepler's Law)\", color='blue') plt.scatter(planet_r_cubed, planet_T_squared, color='red', s=50, label=\"Planets\", zorder=5) # Add planet labels for name, (r, T) in planets.items(): plt.text(r**3, T**2, name, fontsize=9, ha='right') plt.xscale('log') plt.yscale('log') plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True, which='both', ls='--') plt.legend() plt.tight_layout() plt.show() This plot demonstrates the linear relationship between the square of the orbital period and the cube of the orbital radius, visually confirming Kepler's Third Law. The slope of the linear fit is proportional to \\(1/(GM)\\) . The Python code calculates and plots the relationship between the radius and the period, and also plots the square of the period against the cube of the radius to demonstrate the linear relationship predicted by Kepler's Third Law. The linear fit to the \\(T^2\\) vs \\(r^3\\) plot will have a slope equal to \\(\\frac{4\\pi^2}{GM}\\) . 5. Extension to Elliptical Orbits For elliptical orbits, Kepler's Third Law still holds, but the radius \\(r\\) is replaced by the semi-major axis \\(a\\) of the ellipse. The semi-major axis is half of the longest diameter of the ellipse and is the average of the perihelion (closest approach) and aphelion (farthest distance) distances. The law can be written as: \\[ T^2 = \\frac{4\\pi^2 a^3}{GM} \\] where \\(a\\) is the length of the semi-major axis. This extension is crucial for understanding the orbits of planets, comets, and many other celestial bodies that do not follow perfectly circular paths. The derivation for elliptical orbits involves more advanced mathematics and takes into account the varying speed of the orbiting object as it moves along its elliptical path, as described by Kepler's Second Law (the law of equal areas). Deliverables This document serves as the deliverable, providing the derivation of Kepler's Third Law for circular orbits, discussing its implications for astronomy, presenting real-world examples, including a Python computational model to simulate and verify the law, and briefly explaining its extension to elliptical orbits. The Python code included can be executed to generate plots illustrating the relationships discussed. The analysis confirms the proportionality between the square of the orbital period and the cube of the orbital radius, a fundamental principle governing the motion of celestial bodies.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-the-relationship-for-circular-orbits","text":"Consider an object of mass \\(m\\) (e.g., a planet or a satellite) orbiting a much larger object of mass \\(M\\) (e.g., a star or a planet) in a circular orbit of radius \\(r\\) with an orbital period \\(T\\) . The gravitational force between the two objects provides the centripetal force required for the circular motion. According to Newton's Law of Universal Gravitation , the gravitational force \\(F_g\\) is given by: \\[ F_g = G \\frac{Mm}{r^2} \\] where \\(G\\) is the gravitational constant. The centripetal force \\(F_c\\) required to keep the object of mass \\(m\\) moving in a circle of radius \\(r\\) with a speed \\(v\\) is given by: \\[ F_c = \\frac{mv^2}{r} \\] For a stable circular orbit, the gravitational force must equal the centripetal force: \\[ G \\frac{Mm}{r^2} = \\frac{mv^2}{r} \\] We can cancel the mass of the orbiting object \\(m\\) from both sides: \\[ G \\frac{M}{r^2} = \\frac{v^2}{r} \\] The speed \\(v\\) of the orbiting object is related to the orbital radius \\(r\\) and the orbital period \\(T\\) by the formula: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this expression for \\(v\\) into the equation above: \\[ G \\frac{M}{r^2} = \\frac{(2\\pi r / T)^2}{r} \\] Simplify the equation: \\[ G \\frac{M}{r^2} = \\frac{4\\pi^2 r^2}{T^2 r} \\] \\[ G \\frac{M}{r^2} = \\frac{4\\pi^2 r}{T^2} \\] Now, rearrange the equation to solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] This equation shows that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) , with the constant of proportionality being \\(\\frac{4\\pi^2}{GM}\\) . This is Kepler's Third Law for circular orbits.","title":"1. Derivation of the Relationship for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler's Third Law has several crucial implications for astronomy: Determining the Mass of a Central Body: If we know the orbital period \\(T\\) and the orbital radius \\(r\\) of an object orbiting a central body, we can calculate the mass \\(M\\) of the central body using the rearranged formula: $$ M = \\frac{4\\pi^2 r^3}{GT^2} $$ This is how the masses of stars, planets, and even black holes can be estimated by observing the orbits of their satellites or companion stars. Predicting Orbital Periods and Radii: Conversely, if we know the mass of the central body and either the orbital period or the orbital radius of an orbiting object, we can predict the other quantity. This is essential for planning satellite missions and understanding the dynamics of planetary systems. Understanding Planetary Systems: Kepler's Third Law provides a fundamental framework for understanding the structure and evolution of planetary systems. The consistent relationship between orbital periods and radii across different planets in a system supports the idea of a common formation mechanism.","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Let's consider two examples: the Moon orbiting the Earth and the Earth orbiting the Sun.","title":"3. Real-world Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-moon-orbiting-the-earth","text":"Orbital Period of the Moon ( \\(T_{\\text{Moon}}\\) ): \\(\\approx 27.3\\) days \\(\\approx 27.3 \\times 24 \\times 3600\\) seconds \\(\\approx 2.36 \\times 10^6\\) s Average orbital radius of the Moon ( \\(r_{\\text{Moon}}\\) ): \\(\\approx 384,400\\) km \\(\\approx 3.844 \\times 10^8\\) m Mass of the Earth ( \\(M_{\\text{Earth}}\\) ): \\(\\approx 5.972 \\times 10^{24}\\) kg Gravitational constant ( \\(G\\) ): \\(\\approx 6.674 \\times 10^{-11}\\) N\u00b7m\u00b2/kg\u00b2 Let's verify Kepler's Third Law using these values. Calculate \\(\\frac{4\\pi^2 r_{\\text{Moon}}^3}{GM_{\\text{Earth}}}\\) : \\[ \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})} \\approx \\frac{4 \\times (3.14159)^2 \\times 5.66 \\times 10^{25}}{3.985 \\times 10^{14}} \\approx 5.62 \\times 10^{12} \\, \\text{s}^2 \\] Now, let's calculate \\(T_{\\text{Moon}}^2\\) : \\[ (2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12} \\, \\text{s}^2 \\] The calculated value from Kepler's Third Law is very close to the square of the Moon's orbital period, confirming the law.","title":"The Moon Orbiting the Earth:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-earth-orbiting-the-sun","text":"Orbital Period of the Earth ( \\(T_{\\text{Earth}}\\) ): \\(\\approx 365.25\\) days \\(\\approx 365.25 \\times 24 \\times 3600\\) seconds \\(\\approx 3.156 \\times 10^7\\) s Average orbital radius of the Earth ( \\(r_{\\text{Earth}}\\) ): \\(\\approx 1.496 \\times 10^{11}\\) m Mass of the Sun ( \\(M_{\\text{Sun}}\\) ): \\(\\approx 1.989 \\times 10^{30}\\) kg Calculate \\(\\frac{4\\pi^2 r_{\\text{Earth}}^3}{GM_{\\text{Sun}}}\\) : \\[ \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.674 \\times 10^{-11})(1.989 \\times 10^{30})} \\approx \\frac{4 \\times (3.14159)^2 \\times 3.348 \\times 10^{33}}{1.327 \\times 10^{20}} \\approx 1.00 \\times 10^{15} \\, \\text{s}^2 \\] Now, let's calculate \\(T_{\\text{Earth}}^2\\) : \\[ (3.156 \\times 10^7)^2 \\approx 9.96 \\times 10^{14} \\, \\text{s}^2 \\] Again, the calculated value is very close to the square of the Earth's orbital period, validating Kepler's Third Law.","title":"The Earth Orbiting the Sun:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-model","text":"We can create a simplified computational model using Python to simulate circular orbits and observe the relationship between orbital period and radius. Below is an example Python script: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (N\u00b7m\u00b2/kg\u00b2) M = 1.989 * 10**30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(r): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Radii for the curve radii = np.linspace(1e10, 5e12, 100) # in meters T_squared = (orbital_period(radii))**2 r_cubed = radii**3 # Planetary data (semi-major axis in meters, orbital period in seconds) planets = { \"Mercury\": (5.79e10, 7.6e6), \"Venus\": (1.082e11, 1.94e7), \"Earth\": (1.496e11, 3.156e7), \"Mars\": (2.279e11, 5.93e7), \"Jupiter\": (7.785e11, 3.74e8) } # Prepare planet data for plotting planet_r_cubed = [r**3 for r, T in planets.values()] planet_T_squared = [T**2 for r, T in planets.values()] # Plot T^2 vs r^3 on a log-log scale plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=\"T\u00b2 vs r\u00b3 (Kepler's Law)\", color='blue') plt.scatter(planet_r_cubed, planet_T_squared, color='red', s=50, label=\"Planets\", zorder=5) # Add planet labels for name, (r, T) in planets.items(): plt.text(r**3, T**2, name, fontsize=9, ha='right') plt.xscale('log') plt.yscale('log') plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True, which='both', ls='--') plt.legend() plt.tight_layout() plt.show()","title":"4. Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#this-plot-demonstrates-the-linear-relationship-between-the-square-of-the-orbital-period-and-the-cube-of-the-orbital-radius-visually-confirming-keplers-third-law-the-slope-of-the-linear-fit-is-proportional-to-1gm","text":"The Python code calculates and plots the relationship between the radius and the period, and also plots the square of the period against the cube of the radius to demonstrate the linear relationship predicted by Kepler's Third Law. The linear fit to the \\(T^2\\) vs \\(r^3\\) plot will have a slope equal to \\(\\frac{4\\pi^2}{GM}\\) .","title":"This plot demonstrates the linear relationship between the square of the orbital period and the cube of the orbital radius, visually confirming Kepler's Third Law. The slope of the linear fit is proportional to \\(1/(GM)\\)."},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-to-elliptical-orbits","text":"For elliptical orbits, Kepler's Third Law still holds, but the radius \\(r\\) is replaced by the semi-major axis \\(a\\) of the ellipse. The semi-major axis is half of the longest diameter of the ellipse and is the average of the perihelion (closest approach) and aphelion (farthest distance) distances. The law can be written as: \\[ T^2 = \\frac{4\\pi^2 a^3}{GM} \\] where \\(a\\) is the length of the semi-major axis. This extension is crucial for understanding the orbits of planets, comets, and many other celestial bodies that do not follow perfectly circular paths. The derivation for elliptical orbits involves more advanced mathematics and takes into account the varying speed of the orbiting object as it moves along its elliptical path, as described by Kepler's Second Law (the law of equal areas).","title":"5. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"This document serves as the deliverable, providing the derivation of Kepler's Third Law for circular orbits, discussing its implications for astronomy, presenting real-world examples, including a Python computational model to simulate and verify the law, and briefly explaining its extension to elliptical orbits. The Python code included can be executed to generate plots illustrating the relationships discussed. The analysis confirms the proportionality between the square of the orbital period and the cube of the orbital radius, a fundamental principle governing the motion of celestial bodies.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Introduction The concept of escape velocity is fundamental in astrophysics and space exploration. It defines the minimum speed required for an object to break free from a celestial body's gravitational pull. Expanding on this, cosmic velocities extend this concept to define the speeds required for orbiting, escaping, and leaving a star system. This document will define and analyze these velocities, provide mathematical derivations, and discuss their importance in space exploration. Definitions First Cosmic Velocity (Orbital Velocity): This is the minimum velocity required for an object to maintain a stable circular orbit around a celestial body, neglecting atmospheric drag. It is the velocity at which the centrifugal force balances the gravitational force. Second Cosmic Velocity (Escape Velocity): This is the minimum velocity required for an object to escape the gravitational influence of a celestial body and never return. It is the velocity at which the object's kinetic energy equals the magnitude of its gravitational potential energy. Third Cosmic Velocity (Solar Escape Velocity): This is the minimum velocity required for an object to escape the solar system from Earth's orbit. It accounts for the combined gravitational influence of Earth and the Sun. Mathematical Derivations First Cosmic Velocity ( \\(v_1\\) ) For a stable circular orbit, the gravitational force equals the centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\] Where: \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{N m}^2/\\text{kg}^2\\) ) \\(M\\) is the mass of the celestial body \\(m\\) is the mass of the orbiting object \\(r\\) is the radius of the orbit (approximated as the radius of the celestial body for orbits close to the surface) Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Second Cosmic Velocity ( \\(v_2\\) ) The kinetic energy of the object must equal the gravitational potential energy: \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Thus, \\(v_2 = \\sqrt{2} v_1\\) . Third Cosmic Velocity ( \\(v_3\\) ) To calculate the third cosmic velocity, we consider the object's initial velocity (Earth's orbital velocity) and the additional velocity needed to escape the Sun's gravitational pull. Earth's Orbital Velocity ( \\(v_{Earth}\\) ): This is the first cosmic velocity with respect to the Sun at Earth's orbital radius. Solar Escape Velocity at Earth's Orbit ( \\(v_{SolarEscape}\\) ): This is the second cosmic velocity with respect to the Sun at Earth's orbital radius. Third Cosmic Velocity ( \\(v_3\\) ): To calculate the third cosmic velocity (escape from the Solar System starting at Earth's surface), we account for: Escaping Earth's gravity \u2014 requiring Earth's second cosmic velocity \\(v_2\\) . Reaching solar escape velocity at Earth's orbital radius ( \\(v_{SolarEscape}\\) ). Compensating for the orbital velocity of Earth around the Sun ( \\(v_{EarthOrbital}\\) ), which assists or hinders depending on direction. Simplified Calculation: \\[ v_3 = \\sqrt{v_{SolarEscape}^2 + (v_2 - v_{EarthOrbital})^2} \\] This expression assumes the spacecraft launches in the same direction as Earth\u2019s orbital motion. The \\((v_2 - v_{EarthOrbital})\\) term reflects the adjustment needed after escaping Earth to reach the solar escape velocity. Alternatively, if launching directly from Earth's orbit, a more direct delta-v estimate is: \\[ \\Delta v = v_{SolarEscape} - v_{EarthOrbital} \\] \ud83c\udf0d Parameters Used Celestial Body Mass (kg) Radius (m) Earth 5.972 \u00d7 10\u00b2\u2074 6.371 \u00d7 10\u2076 Moon 7.342 \u00d7 10\u00b2\u00b2 1.7371 \u00d7 10\u2076 Mars 6.39 \u00d7 10\u00b2\u00b3 3.390 \u00d7 10\u2076 Jupiter 1.898 \u00d7 10\u00b2\u2077 6.9911 \u00d7 10\u2077 Python Implementation import math import matplotlib.pyplot as plt import pandas as pd def calculate_cosmic_velocities(mass, radius, solar_mass=1.989e30, earth_orbital_radius=1.496e11): G = 6.674e-11 v1 = math.sqrt((G * mass) / radius) v2 = math.sqrt((2 * G * mass) / radius) earth_orbital_velocity = math.sqrt((G * solar_mass) / earth_orbital_radius) solar_escape_velocity = math.sqrt((2 * G * solar_mass) / earth_orbital_radius) # Simplified version: escape Earth and reach solar escape from Earth's orbit v3 = math.sqrt(solar_escape_velocity**2 + (v2 - earth_orbital_velocity)**2) return v1, v2, v3 # Add Moon to celestial bodies celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Moon\": {\"mass\": 7.342e22, \"radius\": 1.7371e6}, \"Mars\": {\"mass\": 6.39e23, \"radius\": 3.390e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7}, } velocities = {} for body, data in celestial_bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data[\"mass\"], data[\"radius\"]) velocities[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} print(\"Cosmic Velocities (in m/s):\") for body, v in velocities.items(): print(f\"{body}:\") print(f\" v1 (Orbital): {v['v1']:.2f} m/s\") print(f\" v2 (Escape): {v['v2']:.2f} m/s\") print(f\" v3 (Solar Escape): {v['v3']:.2f} m/s\") # Tabular display df = pd.DataFrame(velocities).T df.columns = [\"v1 (Orbital)\", \"v2 (Escape)\", \"v3 (Solar Escape)\"] df_kms = df.applymap(lambda x: f\"{x/1000:.2f} km/s\") print(\"\\nCosmic Velocities Table (in km/s):\") print(df_kms) # Visualization bodies = list(velocities.keys()) v1_values = [velocities[body][\"v1\"] for body in bodies] v2_values = [velocities[body][\"v2\"] for body in bodies] v3_values = [velocities[body][\"v3\"] for body in bodies] plt.figure(figsize=(10, 6)) plt.plot(bodies, v1_values, marker='o', linestyle='--', label='First Cosmic Velocity (v1)') plt.plot(bodies, v2_values, marker='o', linestyle='--', label='Second Cosmic Velocity (v2)') plt.plot(bodies, v3_values, marker='o', linestyle='--', label='Third Cosmic Velocity (v3)') plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (m/s)\") plt.title(\"Cosmic Velocities of Celestial Bodies\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() \ud83d\udcca Results (Velocities in km/s) Body v\u2081 (Orbital) v\u2082 (Escape) v\u2083 (Solar Escape) Earth 7.91 km/s 11.18 km/s 16.65 km/s Moon 1.68 km/s 2.38 km/s 15.90 km/s Mars 3.55 km/s 5.03 km/s 16.12 km/s Jupiter 42.09 km/s 59.55 km/s 64.16 km/s Importance in Space Exploration Launching Satellites: The first cosmic velocity is crucial for placing satellites into stable orbits around Earth or other celestial bodies. It ensures that the satellite achieves a balance between gravitational pull and its forward motion, allowing it to remain in orbit without additional propulsion. Missions to Other Planets: The second cosmic velocity is essential for escaping a planet's gravitational pull for interplanetary missions. Achieving this velocity allows spacecraft to break free from Earth's gravity and travel to other planets or celestial bodies. Interstellar Travel: The third cosmic velocity is a fundamental consideration for missions aiming to leave the solar system. It provides the necessary speed to overcome the Sun's gravitational influence and venture into interstellar space. Achieving These Velocities: Achieving these velocities requires significant energy, which drives the development of advanced propulsion systems. Innovations in rocket technology, fuel efficiency, and energy sources are critical to meeting these velocity requirements. Trajectory Planning: Understanding these velocities is critical for calculating trajectories, ensuring that spacecraft reach their destinations with minimal fuel consumption. Precise calculations are necessary to optimize mission efficiency and reduce costs. Asteroid Deflection: Calculating the escape velocity from asteroids is important for missions aiming to deflect or redirect them. Understanding the gravitational influence of asteroids helps in planning missions to mitigate potential threats to Earth. Conclusion The concepts of first, second, and third cosmic velocities are fundamental to space exploration. They provide the necessary framework for understanding the energy requirements for orbital maneuvers and interplanetary travel. The mathematical derivations and calculations presented here are essential tools for planning and executing space missions, pushing the boundaries of human exploration.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The concept of escape velocity is fundamental in astrophysics and space exploration. It defines the minimum speed required for an object to break free from a celestial body's gravitational pull. Expanding on this, cosmic velocities extend this concept to define the speeds required for orbiting, escaping, and leaving a star system. This document will define and analyze these velocities, provide mathematical derivations, and discuss their importance in space exploration.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"First Cosmic Velocity (Orbital Velocity): This is the minimum velocity required for an object to maintain a stable circular orbit around a celestial body, neglecting atmospheric drag. It is the velocity at which the centrifugal force balances the gravitational force. Second Cosmic Velocity (Escape Velocity): This is the minimum velocity required for an object to escape the gravitational influence of a celestial body and never return. It is the velocity at which the object's kinetic energy equals the magnitude of its gravitational potential energy. Third Cosmic Velocity (Solar Escape Velocity): This is the minimum velocity required for an object to escape the solar system from Earth's orbit. It accounts for the combined gravitational influence of Earth and the Sun.","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"For a stable circular orbit, the gravitational force equals the centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\] Where: \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{N m}^2/\\text{kg}^2\\) ) \\(M\\) is the mass of the celestial body \\(m\\) is the mass of the orbiting object \\(r\\) is the radius of the orbit (approximated as the radius of the celestial body for orbits close to the surface) Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"The kinetic energy of the object must equal the gravitational potential energy: \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Thus, \\(v_2 = \\sqrt{2} v_1\\) .","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"To calculate the third cosmic velocity, we consider the object's initial velocity (Earth's orbital velocity) and the additional velocity needed to escape the Sun's gravitational pull. Earth's Orbital Velocity ( \\(v_{Earth}\\) ): This is the first cosmic velocity with respect to the Sun at Earth's orbital radius. Solar Escape Velocity at Earth's Orbit ( \\(v_{SolarEscape}\\) ): This is the second cosmic velocity with respect to the Sun at Earth's orbital radius. Third Cosmic Velocity ( \\(v_3\\) ): To calculate the third cosmic velocity (escape from the Solar System starting at Earth's surface), we account for: Escaping Earth's gravity \u2014 requiring Earth's second cosmic velocity \\(v_2\\) . Reaching solar escape velocity at Earth's orbital radius ( \\(v_{SolarEscape}\\) ). Compensating for the orbital velocity of Earth around the Sun ( \\(v_{EarthOrbital}\\) ), which assists or hinders depending on direction.","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#simplified-calculation","text":"\\[ v_3 = \\sqrt{v_{SolarEscape}^2 + (v_2 - v_{EarthOrbital})^2} \\] This expression assumes the spacecraft launches in the same direction as Earth\u2019s orbital motion. The \\((v_2 - v_{EarthOrbital})\\) term reflects the adjustment needed after escaping Earth to reach the solar escape velocity. Alternatively, if launching directly from Earth's orbit, a more direct delta-v estimate is: \\[ \\Delta v = v_{SolarEscape} - v_{EarthOrbital} \\]","title":"Simplified Calculation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-used","text":"Celestial Body Mass (kg) Radius (m) Earth 5.972 \u00d7 10\u00b2\u2074 6.371 \u00d7 10\u2076 Moon 7.342 \u00d7 10\u00b2\u00b2 1.7371 \u00d7 10\u2076 Mars 6.39 \u00d7 10\u00b2\u00b3 3.390 \u00d7 10\u2076 Jupiter 1.898 \u00d7 10\u00b2\u2077 6.9911 \u00d7 10\u2077","title":"\ud83c\udf0d Parameters Used"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"import math import matplotlib.pyplot as plt import pandas as pd def calculate_cosmic_velocities(mass, radius, solar_mass=1.989e30, earth_orbital_radius=1.496e11): G = 6.674e-11 v1 = math.sqrt((G * mass) / radius) v2 = math.sqrt((2 * G * mass) / radius) earth_orbital_velocity = math.sqrt((G * solar_mass) / earth_orbital_radius) solar_escape_velocity = math.sqrt((2 * G * solar_mass) / earth_orbital_radius) # Simplified version: escape Earth and reach solar escape from Earth's orbit v3 = math.sqrt(solar_escape_velocity**2 + (v2 - earth_orbital_velocity)**2) return v1, v2, v3 # Add Moon to celestial bodies celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Moon\": {\"mass\": 7.342e22, \"radius\": 1.7371e6}, \"Mars\": {\"mass\": 6.39e23, \"radius\": 3.390e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7}, } velocities = {} for body, data in celestial_bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data[\"mass\"], data[\"radius\"]) velocities[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} print(\"Cosmic Velocities (in m/s):\") for body, v in velocities.items(): print(f\"{body}:\") print(f\" v1 (Orbital): {v['v1']:.2f} m/s\") print(f\" v2 (Escape): {v['v2']:.2f} m/s\") print(f\" v3 (Solar Escape): {v['v3']:.2f} m/s\") # Tabular display df = pd.DataFrame(velocities).T df.columns = [\"v1 (Orbital)\", \"v2 (Escape)\", \"v3 (Solar Escape)\"] df_kms = df.applymap(lambda x: f\"{x/1000:.2f} km/s\") print(\"\\nCosmic Velocities Table (in km/s):\") print(df_kms) # Visualization bodies = list(velocities.keys()) v1_values = [velocities[body][\"v1\"] for body in bodies] v2_values = [velocities[body][\"v2\"] for body in bodies] v3_values = [velocities[body][\"v3\"] for body in bodies] plt.figure(figsize=(10, 6)) plt.plot(bodies, v1_values, marker='o', linestyle='--', label='First Cosmic Velocity (v1)') plt.plot(bodies, v2_values, marker='o', linestyle='--', label='Second Cosmic Velocity (v2)') plt.plot(bodies, v3_values, marker='o', linestyle='--', label='Third Cosmic Velocity (v3)') plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (m/s)\") plt.title(\"Cosmic Velocities of Celestial Bodies\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#results-velocities-in-kms","text":"Body v\u2081 (Orbital) v\u2082 (Escape) v\u2083 (Solar Escape) Earth 7.91 km/s 11.18 km/s 16.65 km/s Moon 1.68 km/s 2.38 km/s 15.90 km/s Mars 3.55 km/s 5.03 km/s 16.12 km/s Jupiter 42.09 km/s 59.55 km/s 64.16 km/s","title":"\ud83d\udcca Results (Velocities in km/s)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#launching-satellites","text":"The first cosmic velocity is crucial for placing satellites into stable orbits around Earth or other celestial bodies. It ensures that the satellite achieves a balance between gravitational pull and its forward motion, allowing it to remain in orbit without additional propulsion.","title":"Launching Satellites:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#missions-to-other-planets","text":"The second cosmic velocity is essential for escaping a planet's gravitational pull for interplanetary missions. Achieving this velocity allows spacecraft to break free from Earth's gravity and travel to other planets or celestial bodies.","title":"Missions to Other Planets:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#interstellar-travel","text":"The third cosmic velocity is a fundamental consideration for missions aiming to leave the solar system. It provides the necessary speed to overcome the Sun's gravitational influence and venture into interstellar space.","title":"Interstellar Travel:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#achieving-these-velocities","text":"Achieving these velocities requires significant energy, which drives the development of advanced propulsion systems. Innovations in rocket technology, fuel efficiency, and energy sources are critical to meeting these velocity requirements.","title":"Achieving These Velocities:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#trajectory-planning","text":"Understanding these velocities is critical for calculating trajectories, ensuring that spacecraft reach their destinations with minimal fuel consumption. Precise calculations are necessary to optimize mission efficiency and reduce costs.","title":"Trajectory Planning:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#asteroid-deflection","text":"Calculating the escape velocity from asteroids is important for missions aiming to deflect or redirect them. Understanding the gravitational influence of asteroids helps in planning missions to mitigate potential threats to Earth.","title":"Asteroid Deflection:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"The concepts of first, second, and third cosmic velocities are fundamental to space exploration. They provide the necessary framework for understanding the energy requirements for orbital maneuvers and interplanetary travel. The mathematical derivations and calculations presented here are essential tools for planning and executing space missions, pushing the boundaries of human exploration.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Introduction Understanding the motion of objects under the influence of Earth's gravity is fundamental to space exploration. When a payload is released from a moving rocket near Earth, its subsequent trajectory is governed by its initial conditions (position and velocity at the time of release) and the gravitational force exerted by Earth. This problem explores the different types of trajectories possible and provides a computational tool to simulate and visualize these paths. Theoretical Background The motion of the payload is primarily governed by Newton's Law of Universal Gravitation , which states that every particle in the universe attracts every other particle with a force that is directly proportional to the product of their masses and inversely proportional to the square of the distance between their centers. Mathematically, the force \\(F\\) exerted by Earth (mass \\(M\\) ) on the payload (mass \\(m\\) ) is given by: \\[ F = -G \\frac{Mm}{r^2} \\hat{r} \\] where: - \\(G\\) is the universal gravitational constant ( \\(6.674 \\times 10^{-11} \\,{N\u00b7m}^2/\\text{kg}^2\\) ), - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), - \\(m\\) is the mass of the payload, - \\(r\\) is the distance between the center of Earth and the payload, - \\(\\hat{r}\\) is the unit vector pointing from the center of Earth to the payload. From Newton's second law of motion ( \\(F = ma\\) ), the acceleration \\(a\\) of the payload is: \\[ a = \\frac{F}{m} = -G \\frac{M}{r^2} \\hat{r} \\] This acceleration is always directed towards the center of Earth. Types of Trajectories The type of trajectory the payload will follow depends on its total mechanical energy , which is the sum of its kinetic energy ( \\(K\\) ) and potential energy ( \\(U\\) ). The gravitational potential energy of the payload at a distance \\(r\\) from the center of Earth is: \\[ U = -G \\frac{Mm}{r} \\] The kinetic energy of the payload with velocity \\(v\\) is: \\[ K = \\frac{1}{2} mv^2 \\] The total energy \\(E\\) is: \\[ E = K + U = \\frac{1}{2} mv^2 - G \\frac{Mm}{r} \\] The shape of the trajectory is determined by the sign of the total energy: Elliptical Trajectory ( \\(E < 0\\) ): If the total energy is negative, the payload is bound to Earth and will follow an elliptical orbit. A circle is a special case of an ellipse where the eccentricity is zero. This is typical for payloads that are intended to orbit Earth. Parabolic Trajectory ( \\(E = 0\\) ): If the total energy is exactly zero, the payload will follow a parabolic trajectory. This is the minimum energy required for the payload to escape Earth's gravitational pull and never return. The velocity at which this occurs at a given distance \\(r\\) is the escape velocity : $$ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} $$ Hyperbolic Trajectory ( \\(E > 0\\) ): If the total energy is positive, the payload has more than enough energy to escape Earth's gravity and will follow a hyperbolic trajectory. Numerical Simulation To simulate the motion of the payload, we can use numerical methods to solve the equations of motion. We will use a simple Euler method for this demonstration, but more accurate methods like the Runge-Kutta method can be used for higher precision. Let \\(\\mathbf{r} = (x, y)\\) be the position vector of the payload and \\(\\mathbf{v} = (v_x, v_y)\\) be its velocity vector in a 2D plane (we can extend this to 3D if needed). The acceleration vector \\(\\mathbf{a} = (a_x, a_y)\\) is given by: \\[ a_x = -GM \\frac{x}{(x^2 + y^2)^{3/2}} \\] \\[ a_y = -GM \\frac{y}{(x^2 + y^2)^{3/2}} \\] The Euler method updates the position and velocity at each time step \\(\\Delta t\\) as follows: \\[ \\mathbf{v}_{i+1} = \\mathbf{v}_i + \\mathbf{a}_i \\Delta t \\] \\[ \\mathbf{r}_{i+1} = \\mathbf{r}_i + \\mathbf{v}_i \\Delta t \\] The code has been extended to simulate the trajectories of a payload released from an altitude of 800 km above Earth's surface . We are now investigating multiple launch velocities ranging from 5 km/s to 13 km/s (with 0.5 km/s increments). Each trajectory is computed using the Euler method to numerically solve the equations of motion under Earth's gravitational force. Simulation and Plotting We simulate the trajectories for various initial velocities, starting each payload at a position 800 km above Earth , placed on the right side of Earth (positive x-axis). The velocities tested include: 5.0 km/s 5.5 km/s 6.0 km/s ... 13.0 km/s Each velocity represents a different scenario for the payload's trajectory, which could be elliptical (orbit), escape, or reentry based on the initial conditions. The Earth is drawn to scale in the plot as a blue circle , and the trajectories are displayed accordingly. Re-entry Trajectories: For velocities below the the orbital velocity of Earth at this altitude. Elliptical Trajectories: For velocities near the orbital velocity of Earth at this altitude. Escape Trajectories: For velocities greater than the escape velocity of Earth at the given altitude. The simulation also now visually shows the Earth in the plot for context. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Earth mass (kg) R_earth = 6371e3 # Earth radius (m) # Initial conditions altitude = 800e3 initial_distance = R_earth + altitude initial_position = [initial_distance, 0] # on the right side # Velocity range (in m/s) velocities_kms = np.arange(5.0, 13.5, 0.5) velocities = velocities_kms * 1e3 # Time parameters dt = 1 # time step (s) time_steps = 20000 # Containers for categorized results crashes = [] orbits = [] escapes = [] def simulate_trajectory(position, velocity, steps, dt): pos = np.array(position, dtype=float) vel = np.array(velocity, dtype=float) traj = [pos.copy()] for _ in range(steps): r = np.linalg.norm(pos) if r <= R_earth: return np.array(traj), \"crash\" if r > 10 * initial_distance: return np.array(traj), \"escape\" acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt traj.append(pos.copy()) return np.array(traj), \"orbit\" # Simulate all velocities for v in velocities: v0 = [0, v] traj, kind = simulate_trajectory(initial_position, v0, time_steps, dt) if kind == \"crash\": crashes.append((v, traj)) elif kind == \"orbit\": orbits.append((v, traj)) elif kind == \"escape\": escapes.append((v, traj)) # --- Plot Crash Cases (Zoomed In) --- plt.figure(figsize=(8, 8)) for v, traj in crashes: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Trajectories that Crash into Earth\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-1e7, 1.5e7) plt.ylim(-1e7, 1.5e7) plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Plot Orbital Cases (Zoomed Out) --- plt.figure(figsize=(8, 8)) for v, traj in orbits: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Orbital Trajectories\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-5e7, 5e7) plt.ylim(-5e7, 5e7) plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Plot Escape Cases (Zoomed Out More) --- plt.figure(figsize=(8, 8)) for v, traj in escapes: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Trajectories that Escape Earth\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-8e7, 1e8) plt.ylim(-8e7, 1e8) plt.grid(True) plt.legend() plt.tight_layout() plt.show() Analysis and Discussion The simulation demonstrates different types of trajectories based on the initial velocity of the payload. Reentry: A reentry trajectory is one where the payload is directed back towards Earth's atmosphere. This occurs when the payload's velocity is lower than the orbital velocity at its altitude, causing it to lose altitude over time due to gravity. The Crash into Earth case illustrates this, where the payload's elliptical orbit intersects with Earth. Orbital Insertion: For a payload to be inserted into a stable orbit around Earth, its initial velocity at a certain altitude must be carefully chosen. The velocity should be high enough to counteract gravity and prevent the payload from falling back to Earth, but not so high that it escapes Earth's gravitational pull. The simulation with Orbital trajectories shows an elliptical trajectory, which, with fine-tuning of the initial velocity, could become a circular orbit. Orbital insertion typically involves achieving a specific velocity vector at a desired altitude. Escape: An escape trajectory is achieved when the payload's initial velocity is equal to or greater than the escape velocity at its initial position. In this case, the payload will have enough kinetic energy to overcome Earth's gravitational potential energy and move away from Earth indefinitely (following a parabolic or hyperbolic path). The Escape Earth simulation shows the payload moving away from Earth. Further Considerations and Improvements More Accurate Numerical Methods: The Euler method is simple but can be inaccurate for long simulations or large time steps. Using methods like the Runge-Kutta 4th order method would provide more accurate results. 3D Simulation: For more realistic scenarios, the simulation should be extended to three dimensions. Atmospheric Drag: In the lower altitudes, atmospheric drag plays a significant role in the trajectory of a payload, causing it to slow down and eventually burn up or land. This effect is not included in the current simulation. Perturbations: The gravitational forces of other celestial bodies (like the Moon and the Sun) can also affect the payload's trajectory over long periods. These perturbations are not considered here. Visualization: More sophisticated visualization tools can be used to create animations of the payload's motion. Conclusion The trajectory of a payload released near Earth is highly dependent on its initial conditions, particularly its velocity. By understanding the relationship between the total energy and the type of trajectory, we can plan missions for orbital insertion, reentry, or escape. Numerical simulations provide a powerful tool for predicting and visualizing these trajectories, aiding in the design and execution of space missions. The provided Python script offers a basic framework for simulating these scenarios, which can be further refined to include more complex physical phenomena for increased accuracy.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#introduction","text":"Understanding the motion of objects under the influence of Earth's gravity is fundamental to space exploration. When a payload is released from a moving rocket near Earth, its subsequent trajectory is governed by its initial conditions (position and velocity at the time of release) and the gravitational force exerted by Earth. This problem explores the different types of trajectories possible and provides a computational tool to simulate and visualize these paths.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"The motion of the payload is primarily governed by Newton's Law of Universal Gravitation , which states that every particle in the universe attracts every other particle with a force that is directly proportional to the product of their masses and inversely proportional to the square of the distance between their centers. Mathematically, the force \\(F\\) exerted by Earth (mass \\(M\\) ) on the payload (mass \\(m\\) ) is given by: \\[ F = -G \\frac{Mm}{r^2} \\hat{r} \\] where: - \\(G\\) is the universal gravitational constant ( \\(6.674 \\times 10^{-11} \\,{N\u00b7m}^2/\\text{kg}^2\\) ), - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), - \\(m\\) is the mass of the payload, - \\(r\\) is the distance between the center of Earth and the payload, - \\(\\hat{r}\\) is the unit vector pointing from the center of Earth to the payload. From Newton's second law of motion ( \\(F = ma\\) ), the acceleration \\(a\\) of the payload is: \\[ a = \\frac{F}{m} = -G \\frac{M}{r^2} \\hat{r} \\] This acceleration is always directed towards the center of Earth.","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"The type of trajectory the payload will follow depends on its total mechanical energy , which is the sum of its kinetic energy ( \\(K\\) ) and potential energy ( \\(U\\) ). The gravitational potential energy of the payload at a distance \\(r\\) from the center of Earth is: \\[ U = -G \\frac{Mm}{r} \\] The kinetic energy of the payload with velocity \\(v\\) is: \\[ K = \\frac{1}{2} mv^2 \\] The total energy \\(E\\) is: \\[ E = K + U = \\frac{1}{2} mv^2 - G \\frac{Mm}{r} \\] The shape of the trajectory is determined by the sign of the total energy: Elliptical Trajectory ( \\(E < 0\\) ): If the total energy is negative, the payload is bound to Earth and will follow an elliptical orbit. A circle is a special case of an ellipse where the eccentricity is zero. This is typical for payloads that are intended to orbit Earth. Parabolic Trajectory ( \\(E = 0\\) ): If the total energy is exactly zero, the payload will follow a parabolic trajectory. This is the minimum energy required for the payload to escape Earth's gravitational pull and never return. The velocity at which this occurs at a given distance \\(r\\) is the escape velocity : $$ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} $$ Hyperbolic Trajectory ( \\(E > 0\\) ): If the total energy is positive, the payload has more than enough energy to escape Earth's gravity and will follow a hyperbolic trajectory.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"To simulate the motion of the payload, we can use numerical methods to solve the equations of motion. We will use a simple Euler method for this demonstration, but more accurate methods like the Runge-Kutta method can be used for higher precision. Let \\(\\mathbf{r} = (x, y)\\) be the position vector of the payload and \\(\\mathbf{v} = (v_x, v_y)\\) be its velocity vector in a 2D plane (we can extend this to 3D if needed). The acceleration vector \\(\\mathbf{a} = (a_x, a_y)\\) is given by: \\[ a_x = -GM \\frac{x}{(x^2 + y^2)^{3/2}} \\] \\[ a_y = -GM \\frac{y}{(x^2 + y^2)^{3/2}} \\] The Euler method updates the position and velocity at each time step \\(\\Delta t\\) as follows: \\[ \\mathbf{v}_{i+1} = \\mathbf{v}_i + \\mathbf{a}_i \\Delta t \\] \\[ \\mathbf{r}_{i+1} = \\mathbf{r}_i + \\mathbf{v}_i \\Delta t \\] The code has been extended to simulate the trajectories of a payload released from an altitude of 800 km above Earth's surface . We are now investigating multiple launch velocities ranging from 5 km/s to 13 km/s (with 0.5 km/s increments). Each trajectory is computed using the Euler method to numerically solve the equations of motion under Earth's gravitational force.","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-and-plotting","text":"We simulate the trajectories for various initial velocities, starting each payload at a position 800 km above Earth , placed on the right side of Earth (positive x-axis). The velocities tested include: 5.0 km/s 5.5 km/s 6.0 km/s ... 13.0 km/s Each velocity represents a different scenario for the payload's trajectory, which could be elliptical (orbit), escape, or reentry based on the initial conditions. The Earth is drawn to scale in the plot as a blue circle , and the trajectories are displayed accordingly. Re-entry Trajectories: For velocities below the the orbital velocity of Earth at this altitude. Elliptical Trajectories: For velocities near the orbital velocity of Earth at this altitude. Escape Trajectories: For velocities greater than the escape velocity of Earth at the given altitude. The simulation also now visually shows the Earth in the plot for context. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Earth mass (kg) R_earth = 6371e3 # Earth radius (m) # Initial conditions altitude = 800e3 initial_distance = R_earth + altitude initial_position = [initial_distance, 0] # on the right side # Velocity range (in m/s) velocities_kms = np.arange(5.0, 13.5, 0.5) velocities = velocities_kms * 1e3 # Time parameters dt = 1 # time step (s) time_steps = 20000 # Containers for categorized results crashes = [] orbits = [] escapes = [] def simulate_trajectory(position, velocity, steps, dt): pos = np.array(position, dtype=float) vel = np.array(velocity, dtype=float) traj = [pos.copy()] for _ in range(steps): r = np.linalg.norm(pos) if r <= R_earth: return np.array(traj), \"crash\" if r > 10 * initial_distance: return np.array(traj), \"escape\" acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt traj.append(pos.copy()) return np.array(traj), \"orbit\" # Simulate all velocities for v in velocities: v0 = [0, v] traj, kind = simulate_trajectory(initial_position, v0, time_steps, dt) if kind == \"crash\": crashes.append((v, traj)) elif kind == \"orbit\": orbits.append((v, traj)) elif kind == \"escape\": escapes.append((v, traj)) # --- Plot Crash Cases (Zoomed In) --- plt.figure(figsize=(8, 8)) for v, traj in crashes: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Trajectories that Crash into Earth\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-1e7, 1.5e7) plt.ylim(-1e7, 1.5e7) plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Plot Orbital Cases (Zoomed Out) --- plt.figure(figsize=(8, 8)) for v, traj in orbits: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Orbital Trajectories\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-5e7, 5e7) plt.ylim(-5e7, 5e7) plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Plot Escape Cases (Zoomed Out More) --- plt.figure(figsize=(8, 8)) for v, traj in escapes: plt.plot(traj[:, 0], traj[:, 1], label=f\"{v/1000:.1f} km/s\") plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3)) plt.scatter(0, 0, color='blue') plt.title(\"Trajectories that Escape Earth\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.axis('equal') plt.xlim(-8e7, 1e8) plt.ylim(-8e7, 1e8) plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Simulation and Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/#analysis-and-discussion","text":"The simulation demonstrates different types of trajectories based on the initial velocity of the payload.","title":"Analysis and Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#reentry","text":"A reentry trajectory is one where the payload is directed back towards Earth's atmosphere. This occurs when the payload's velocity is lower than the orbital velocity at its altitude, causing it to lose altitude over time due to gravity. The Crash into Earth case illustrates this, where the payload's elliptical orbit intersects with Earth.","title":"Reentry:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-insertion","text":"For a payload to be inserted into a stable orbit around Earth, its initial velocity at a certain altitude must be carefully chosen. The velocity should be high enough to counteract gravity and prevent the payload from falling back to Earth, but not so high that it escapes Earth's gravitational pull. The simulation with Orbital trajectories shows an elliptical trajectory, which, with fine-tuning of the initial velocity, could become a circular orbit. Orbital insertion typically involves achieving a specific velocity vector at a desired altitude.","title":"Orbital Insertion:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape","text":"An escape trajectory is achieved when the payload's initial velocity is equal to or greater than the escape velocity at its initial position. In this case, the payload will have enough kinetic energy to overcome Earth's gravitational potential energy and move away from Earth indefinitely (following a parabolic or hyperbolic path). The Escape Earth simulation shows the payload moving away from Earth.","title":"Escape:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#further-considerations-and-improvements","text":"More Accurate Numerical Methods: The Euler method is simple but can be inaccurate for long simulations or large time steps. Using methods like the Runge-Kutta 4th order method would provide more accurate results. 3D Simulation: For more realistic scenarios, the simulation should be extended to three dimensions. Atmospheric Drag: In the lower altitudes, atmospheric drag plays a significant role in the trajectory of a payload, causing it to slow down and eventually burn up or land. This effect is not included in the current simulation. Perturbations: The gravitational forces of other celestial bodies (like the Moon and the Sun) can also affect the payload's trajectory over long periods. These perturbations are not considered here. Visualization: More sophisticated visualization tools can be used to create animations of the payload's motion.","title":"Further Considerations and Improvements"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"The trajectory of a payload released near Earth is highly dependent on its initial conditions, particularly its velocity. By understanding the relationship between the total energy and the type of trajectory, we can plan missions for orbital insertion, reentry, or escape. Numerical simulations provide a powerful tool for predicting and visualizing these trajectories, aiding in the design and execution of space missions. The provided Python script offers a basic framework for simulating these scenarios, which can be further refined to include more complex physical phenomena for increased accuracy.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is easy to observe when ripples from different points meet. These patterns reveal how waves combine \u2014 either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns helps us understand wave behavior in a visual and intuitive way. This task allows us to explore the effects of wave phase, coherence, and geometry. Task Description A circular wave emitted from a point source located at \\((x_0, y_0)\\) is modeled by the following equation: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) : Water surface displacement at point \\((x, y)\\) and time \\(t\\) \\(A\\) : Wave amplitude \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (with \\(\\lambda\\) as wavelength) \\(\\omega = 2\\pi f\\) : Angular frequency (with \\(f\\) as frequency) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source \\(\\phi\\) : Initial phase When multiple sources emit waves, we use the principle of superposition: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Python Simulation Code To simulate and visualize the interference patterns for various point source configurations, use the following Python code. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D import os import matplotlib.ticker from matplotlib.colors import LinearSegmentedColormap # --- Wave Parameters --- A = 1 # Amplitude wavelength = 2 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 # Phase # --- Coordinate Grid --- x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # --- Polygon Vertex Generator --- def polygon_vertices(n_sides, radius=4): return [ (radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides) ] # --- Wave from a Single Source --- def wave_source(x0, y0, t): R = np.sqrt((X - x0)**2 + (Y - y0)**2) R[R == 0] = 1e-6 # avoid division by zero return (A / R) * np.cos(k * R - omega * t + phi) # --- Superposition of Waves --- def superpose_sources(positions, t=0): Z = np.zeros_like(X) for (x0, y0) in positions: Z += wave_source(x0, y0, t) return Z # --- 3D Plotting Helper --- def plot_3d(Z, title, filename): fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Define custom colormap with smooth transitions colors = ['yellow', 'green', 'blue', 'purple', 'red'] cmap = LinearSegmentedColormap.from_list('custom_div', colors) # Plot the surface with the custom colormap surf = ax.plot_surface(X, Y, Z, cmap=cmap, edgecolor='none') ax.set_title(title) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') # Ensure symmetric Z-axis limits to clearly show negative displacement z_max = np.max(np.abs(Z)) ax.set_zlim(-z_max, z_max) # Set more frequent Z-axis ticks for precise information ax.zaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10)) # Adjust viewing angle for better visualization of troughs ax.view_init(elev=30, azim=-45) # Add a color bar to the side of the plot fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10, label='Displacement') plt.tight_layout() plt.savefig(filename) plt.show() # --- Static Visualizations (Now in 3D) --- plot_3d(superpose_sources([(0, 0)], t=0), \"One Source\", \"one_source_3d.png\") plot_3d(superpose_sources([(-3, 0), (3, 0)], t=0), \"Two Sources\", \"two_sources_3d.png\") plot_3d( superpose_sources(polygon_vertices(3)), \"Three Sources (Triangle)\", \"triangle_3d.png\", ) plot_3d( superpose_sources(polygon_vertices(5)), \"Five Sources (Pentagon)\", \"pentagon_3d.png\", ) # --- Optional: Animated GIF of Pentagon Interference (unchanged - difficult to map colors directly to values in a heatmap) --- def generate_gif(positions, filename=\"interference_pentagon.gif\", frames=60): fig, ax = plt.subplots(figsize=(6, 5)) im = ax.imshow( superpose_sources(positions, t=0), extent=(-10, 10, -10, 10), cmap='coolwarm', # Keep coolwarm for the animation. Custom colormaps are difficult with imshow. origin='lower', ) ax.set_title(\"Wave Interference Animation\") ax.set_xlabel('x') ax.set_ylabel('y') # Adding a colorbar for the 2D heatmap as well plt.colorbar(im, label='Displacement') def update(frame): Z = superpose_sources(positions, t=frame * 0.2) im.set_array(Z) return [im] ani = FuncAnimation(fig, update, frames=frames, interval=80, blit=True) ani.save(filename, writer='pillow') plt.close() generate_gif(polygon_vertices(5)) # Generates 'interference_pentagon.gif' Observations One Source: Symmetrical ripples, no interference Two Sources: Alternating regions of constructive/destructive interference Triangle/Pentagon: Clear geometric interference with repeating patterns Deliverables \u2705 Static plots: one_source.png , two_sources.png , triangle.png , pentagon.png \u2705 Animation: interference_pentagon.gif \u2705 3D Surface Visualization \u2705 Full Python simulation script embedded above","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is easy to observe when ripples from different points meet. These patterns reveal how waves combine \u2014 either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns helps us understand wave behavior in a visual and intuitive way. This task allows us to explore the effects of wave phase, coherence, and geometry.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-description","text":"A circular wave emitted from a point source located at \\((x_0, y_0)\\) is modeled by the following equation: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) : Water surface displacement at point \\((x, y)\\) and time \\(t\\) \\(A\\) : Wave amplitude \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (with \\(\\lambda\\) as wavelength) \\(\\omega = 2\\pi f\\) : Angular frequency (with \\(f\\) as frequency) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source \\(\\phi\\) : Initial phase When multiple sources emit waves, we use the principle of superposition: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\]","title":"Task Description"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"To simulate and visualize the interference patterns for various point source configurations, use the following Python code. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D import os import matplotlib.ticker from matplotlib.colors import LinearSegmentedColormap # --- Wave Parameters --- A = 1 # Amplitude wavelength = 2 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 # Phase # --- Coordinate Grid --- x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # --- Polygon Vertex Generator --- def polygon_vertices(n_sides, radius=4): return [ (radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides) ] # --- Wave from a Single Source --- def wave_source(x0, y0, t): R = np.sqrt((X - x0)**2 + (Y - y0)**2) R[R == 0] = 1e-6 # avoid division by zero return (A / R) * np.cos(k * R - omega * t + phi) # --- Superposition of Waves --- def superpose_sources(positions, t=0): Z = np.zeros_like(X) for (x0, y0) in positions: Z += wave_source(x0, y0, t) return Z # --- 3D Plotting Helper --- def plot_3d(Z, title, filename): fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Define custom colormap with smooth transitions colors = ['yellow', 'green', 'blue', 'purple', 'red'] cmap = LinearSegmentedColormap.from_list('custom_div', colors) # Plot the surface with the custom colormap surf = ax.plot_surface(X, Y, Z, cmap=cmap, edgecolor='none') ax.set_title(title) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') # Ensure symmetric Z-axis limits to clearly show negative displacement z_max = np.max(np.abs(Z)) ax.set_zlim(-z_max, z_max) # Set more frequent Z-axis ticks for precise information ax.zaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10)) # Adjust viewing angle for better visualization of troughs ax.view_init(elev=30, azim=-45) # Add a color bar to the side of the plot fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10, label='Displacement') plt.tight_layout() plt.savefig(filename) plt.show() # --- Static Visualizations (Now in 3D) --- plot_3d(superpose_sources([(0, 0)], t=0), \"One Source\", \"one_source_3d.png\") plot_3d(superpose_sources([(-3, 0), (3, 0)], t=0), \"Two Sources\", \"two_sources_3d.png\") plot_3d( superpose_sources(polygon_vertices(3)), \"Three Sources (Triangle)\", \"triangle_3d.png\", ) plot_3d( superpose_sources(polygon_vertices(5)), \"Five Sources (Pentagon)\", \"pentagon_3d.png\", ) # --- Optional: Animated GIF of Pentagon Interference (unchanged - difficult to map colors directly to values in a heatmap) --- def generate_gif(positions, filename=\"interference_pentagon.gif\", frames=60): fig, ax = plt.subplots(figsize=(6, 5)) im = ax.imshow( superpose_sources(positions, t=0), extent=(-10, 10, -10, 10), cmap='coolwarm', # Keep coolwarm for the animation. Custom colormaps are difficult with imshow. origin='lower', ) ax.set_title(\"Wave Interference Animation\") ax.set_xlabel('x') ax.set_ylabel('y') # Adding a colorbar for the 2D heatmap as well plt.colorbar(im, label='Displacement') def update(frame): Z = superpose_sources(positions, t=frame * 0.2) im.set_array(Z) return [im] ani = FuncAnimation(fig, update, frames=frames, interval=80, blit=True) ani.save(filename, writer='pillow') plt.close() generate_gif(polygon_vertices(5)) # Generates 'interference_pentagon.gif'","title":"Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"One Source: Symmetrical ripples, no interference Two Sources: Alternating regions of constructive/destructive interference Triangle/Pentagon: Clear geometric interference with repeating patterns","title":"Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"\u2705 Static plots: one_source.png , two_sources.png , triangle.png , pentagon.png \u2705 Animation: interference_pentagon.gif \u2705 3D Surface Visualization \u2705 Full Python simulation script embedded above","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force, expressed as: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] governs the motion of charged particles in electric and magnetic fields. This fundamental law is critical in applications ranging from plasma physics and particle accelerators to astrophysical phenomena. Through simulation, we can visualize and understand how particles move under the influence of these fields. 1. Exploration of Applications Particle Accelerators : Lorentz force is used to steer and accelerate particles. Mass Spectrometers : Charged particles are deflected by magnetic fields to determine mass-to-charge ratios. Fusion Devices (e.g., Tokamaks) : Magnetic confinement relies on controlled charged particle motion. Electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields are essential tools for manipulating charged particles in controlled environments. 2. Simulation Assumptions We use the following values for all simulations: Charge: \\(q = 1 \\, \\text{C}\\) Mass: \\(m = 1 \\, \\text{g} = 0.001 \\, \\text{kg}\\) Time step: \\(\\Delta t = 0.01\\) s Integration: Euler method 3. Simulating Trajectories Under Various Conditions A. Circular Motion in a Uniform Magnetic Field No electric field. Particle moves perpendicular to \\(\\vec{B}\\) . \\[ \\vec{F} = q \\vec{v} \\times \\vec{B} \\] Expected result: circular path. import numpy as np import matplotlib.pyplot as plt q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 0.0]) dt = 1e-6 steps = 5000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) plt.plot(r_list[:, 0], r_list[:, 1]) plt.xlabel('x') plt.ylabel('y') plt.title('Circular trajectory (v \u22a5 B)') plt.axis('equal') plt.grid(True) plt.show() B. Spiral (Helical) Motion Along the Z-axis Introduce a velocity component along the magnetic field direction ( \\(z\\) ): \\[ \\vec{v}_0 = [0.0, -2.0, 2.0] \\] This leads to helical motion . import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 2.0]) dt = 1e-6 steps = 10000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(r_list[:, 0], r_list[:, 1], r_list[:, 2]) ax.set_title('Spiral along the z-axis') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') plt.show() C. Complex Trajectory in an Inclined Magnetic Field Using an inclined magnetic field and no electric field: \\[ \\vec{B} = [0.2, 0.0, 1.0], \\quad \\vec{E} = [0.0, 0.0, 0.0] \\] This setup results in a complex 3D spiral trajectory , due to the magnetic field having components in both the \\(x\\) and \\(z\\) directions. The particle spirals and drifts along an inclined axis. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0.2, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 2.0]) dt = 1e-6 steps = 10000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(r_list[:, 0], r_list[:, 1], r_list[:, 2]) ax.set_title('Complex 3D trajectory (inclined B)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') plt.show() 4. Parameter Exploration We explore how changes in the following affect particle trajectories: Electric and magnetic field strengths ( \\(|\\vec{E}|, |\\vec{B}|\\) ) Initial velocity \\(\\vec{v}_0\\) Charge \\(q\\) and mass \\(m\\) Key physical quantities: Larmor Radius: \\[ r_L = \\frac{m v_\\perp}{|q B|} \\] Cyclotron Frequency: \\[ \\omega_c = \\frac{|q B|}{m} \\] Drift Velocity in Crossed Fields: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] These determine whether the particle undergoes tight circular motion, slow spirals, or fast linear drifts. 5. Visualization Summary Scenarios Visualized: Circular motion in 2D under uniform \\(\\vec{B}\\) Spiral (helical) motion along \\(z\\) -axis with initial velocity component in \\(\\vec{B}\\) direction Complex drift/spiral motion under an inclined \\(\\vec{B}\\) field Each plot demonstrates how the Lorentz force shapes the trajectory based on the field configuration. 6. Discussion and Real-World Relevance These simulations relate to practical technologies: Cyclotrons : Acceleration through circular paths Magnetic Traps : Confinement using Lorentz force balancing Fusion Reactors : Plasma control via \\(\\vec{E}\\) and \\(\\vec{B}\\) shaping Mass Spectrometry : Field-dependent ion separation Understanding and simulating the Lorentz force enhances both theoretical insight and engineering capability.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] governs the motion of charged particles in electric and magnetic fields. This fundamental law is critical in applications ranging from plasma physics and particle accelerators to astrophysical phenomena. Through simulation, we can visualize and understand how particles move under the influence of these fields.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"Particle Accelerators : Lorentz force is used to steer and accelerate particles. Mass Spectrometers : Charged particles are deflected by magnetic fields to determine mass-to-charge ratios. Fusion Devices (e.g., Tokamaks) : Magnetic confinement relies on controlled charged particle motion. Electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields are essential tools for manipulating charged particles in controlled environments.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulation-assumptions","text":"We use the following values for all simulations: Charge: \\(q = 1 \\, \\text{C}\\) Mass: \\(m = 1 \\, \\text{g} = 0.001 \\, \\text{kg}\\) Time step: \\(\\Delta t = 0.01\\) s Integration: Euler method","title":"2. Simulation Assumptions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-simulating-trajectories-under-various-conditions","text":"","title":"3. Simulating Trajectories Under Various Conditions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#a-circular-motion-in-a-uniform-magnetic-field","text":"No electric field. Particle moves perpendicular to \\(\\vec{B}\\) . \\[ \\vec{F} = q \\vec{v} \\times \\vec{B} \\] Expected result: circular path. import numpy as np import matplotlib.pyplot as plt q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 0.0]) dt = 1e-6 steps = 5000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) plt.plot(r_list[:, 0], r_list[:, 1]) plt.xlabel('x') plt.ylabel('y') plt.title('Circular trajectory (v \u22a5 B)') plt.axis('equal') plt.grid(True) plt.show()","title":"A. Circular Motion in a Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#b-spiral-helical-motion-along-the-z-axis","text":"Introduce a velocity component along the magnetic field direction ( \\(z\\) ): \\[ \\vec{v}_0 = [0.0, -2.0, 2.0] \\] This leads to helical motion . import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 2.0]) dt = 1e-6 steps = 10000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(r_list[:, 0], r_list[:, 1], r_list[:, 2]) ax.set_title('Spiral along the z-axis') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') plt.show()","title":"B. Spiral (Helical) Motion Along the Z-axis"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#c-complex-trajectory-in-an-inclined-magnetic-field","text":"Using an inclined magnetic field and no electric field: \\[ \\vec{B} = [0.2, 0.0, 1.0], \\quad \\vec{E} = [0.0, 0.0, 0.0] \\] This setup results in a complex 3D spiral trajectory , due to the magnetic field having components in both the \\(x\\) and \\(z\\) directions. The particle spirals and drifts along an inclined axis. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0.2, 0, 1.0]) E = np.array([0, 0, 0]) r = np.array([0.0, 0.0, 0.0]) v = np.array([0.0, -2.0, 2.0]) dt = 1e-6 steps = 10000 r_list = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt r_list.append(r.copy()) r_list = np.array(r_list) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(r_list[:, 0], r_list[:, 1], r_list[:, 2]) ax.set_title('Complex 3D trajectory (inclined B)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') plt.show()","title":"C. Complex Trajectory in an Inclined Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-parameter-exploration","text":"We explore how changes in the following affect particle trajectories: Electric and magnetic field strengths ( \\(|\\vec{E}|, |\\vec{B}|\\) ) Initial velocity \\(\\vec{v}_0\\) Charge \\(q\\) and mass \\(m\\) Key physical quantities:","title":"4. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#larmor-radius","text":"\\[ r_L = \\frac{m v_\\perp}{|q B|} \\]","title":"Larmor Radius:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#cyclotron-frequency","text":"\\[ \\omega_c = \\frac{|q B|}{m} \\]","title":"Cyclotron Frequency:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#drift-velocity-in-crossed-fields","text":"\\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] These determine whether the particle undergoes tight circular motion, slow spirals, or fast linear drifts.","title":"Drift Velocity in Crossed Fields:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-visualization-summary","text":"","title":"5. Visualization Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenarios-visualized","text":"Circular motion in 2D under uniform \\(\\vec{B}\\) Spiral (helical) motion along \\(z\\) -axis with initial velocity component in \\(\\vec{B}\\) direction Complex drift/spiral motion under an inclined \\(\\vec{B}\\) field Each plot demonstrates how the Lorentz force shapes the trajectory based on the field configuration.","title":"Scenarios Visualized:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-discussion-and-real-world-relevance","text":"These simulations relate to practical technologies: Cyclotrons : Acceleration through circular paths Magnetic Traps : Confinement using Lorentz force balancing Fusion Reactors : Plasma control via \\(\\vec{E}\\) and \\(\\vec{B}\\) shaping Mass Spectrometry : Field-dependent ion separation Understanding and simulating the Lorentz force enhances both theoretical insight and engineering capability.","title":"6. Discussion and Real-World Relevance"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Introduction and Motivation Calculating equivalent resistance is a fundamental task in circuit analysis. While traditional approaches use series and parallel simplification rules manually, graph theory provides a powerful alternative \u2014 transforming circuit analysis into an algorithmic graph simplification process. Circuits can be represented as graphs : - Nodes = junctions - Edges = resistors (with resistance as weight) By identifying series and parallel patterns in the graph, we can iteratively reduce it to compute total resistance between two terminals. This approach is: - Scalable for large networks - Automatable for software - Insightful for understanding electrical connectivity and topology Learning Goals After completing this task, you should be able to: Represent a resistor network as a weighted graph. Apply reduction rules (series and parallel) using graph algorithms. Implement an algorithm that simplifies arbitrary configurations. Analyze different circuit structures programmatically. Series Connection Two resistors R\u2081 and R\u2082 in series: \\[ R_{eq} = R_1 + R_2 \\] Parallel Connection Two resistors R\u2081 and R\u2082 in parallel: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\quad \\Rightarrow \\quad R_{eq} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} \\] Implementation in Python with networkx Below is a complete Python implementation and visualization of step-by-step circuit simplification using networkx . code import matplotlib.pyplot as plt import networkx as nx def draw_circuit(G, pos, title, highlight_paths=None): plt.figure(figsize=(10, 6)) node_colors = ['#4CAF50' if node in ['start', 'end'] else '#2196F3' for node in G.nodes()] # Draw nodes and edges nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=1800, edgecolors='black', linewidths=2) nx.draw_networkx_labels(G, pos, font_size=14, font_weight='bold') # Draw all edges first in black (thin) nx.draw_networkx_edges(G, pos, width=2, edge_color='black') # Draw highlighted edges on top (thicker) if highlight_paths: for i, path in enumerate(highlight_paths): color = ['#FF5722', '#3F51B5', '#009688'][i % 3] # Orange, Blue, Teal nx.draw_networkx_edges(G, pos, edgelist=path, edge_color=color, width=6, alpha=0.7) # Add resistance labels with white background for readability edge_labels = {(u, v): f\"{d['resistance']}\u03a9\" for u, v, d in G.edges(data=True)} nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=12, bbox=dict(facecolor='white', edgecolor='none', alpha=0.8, boxstyle='round,pad=0.3')) plt.title(title, fontsize=16, pad=20) plt.axis('off') plt.tight_layout() plt.show() # ================================================================= # Circuit 1: Complex Parallel-Series Combination # ================================================================= G1 = nx.Graph() G1.add_edge('start', 'A', resistance=4) G1.add_edge('A', 'C', resistance=2) G1.add_edge('start', 'B', resistance=8) G1.add_edge('B', 'C', resistance=4) G1.add_edge('C', 'end', resistance=6) pos1 = { 'start': (0, 0), 'A': (1, 1), 'B': (1, -1), 'C': (2, 0), 'end': (3, 0) } draw_circuit(G1, pos1, \"Circuit 1: Parallel Paths (start-A-C and start-B-C)\", highlight_paths=[ [('start', 'A'), ('A', 'C')], # Orange path [('start', 'B'), ('B', 'C')] # Blue path ]) # ================================================================= # Circuit 2: Pure Parallel Configuration (Fixed Version) # ================================================================= plt.figure(figsize=(10, 6)) G2 = nx.MultiGraph() pos2 = { 'start': (0, 0), 'C': (3, 0), 'end': (6, 0) } # Add edges G2.add_edge('start', 'C', resistance=6) G2.add_edge('start', 'C', resistance=12) G2.add_edge('C', 'end', resistance=6) # Draw nodes nx.draw_networkx_nodes(G2, pos2, node_size=1800, node_color=['#4CAF50', '#2196F3', '#4CAF50']) nx.draw_networkx_labels(G2, pos2, font_size=14, font_weight='bold') # Draw edges with clear labeling # First parallel resistor (6\u03a9) nx.draw_networkx_edges(G2, pos2, edgelist=[('start', 'C')], edge_color='#FF5722', width=4, connectionstyle=\"arc3,rad=0.15\") # Label for first parallel resistor plt.text(1.5, 0.25, \"6\u03a9\", ha='center', va='center', fontsize=12, color='black', bbox=dict(facecolor='white', alpha=1, boxstyle='round,pad=0.3')) # Second parallel resistor (12\u03a9) nx.draw_networkx_edges(G2, pos2, edgelist=[('start', 'C')], edge_color='#3F51B5', width=4, connectionstyle=\"arc3,rad=-0.15\") # Label for second parallel resistor plt.text(1.5, -0.25, \"12\u03a9\", ha='center', va='center', fontsize=12, color='black', bbox=dict(facecolor='white', alpha=1, boxstyle='round,pad=0.3')) # Series resistor (6\u03a9) nx.draw_networkx_edges(G2, pos2, edgelist=[('C', 'end')], width=3) plt.text(4.5, 0, \"6\u03a9\", ha='center', va='center', fontsize=12, color='black', bbox=dict(facecolor='white', alpha=1, boxstyle='round,pad=0.3')) plt.title(\"Circuit 2: Parallel Configuration (6\u03a9 || 12\u03a9)\", fontsize=16, pad=20) plt.xlim(-0.5, 6.5) plt.ylim(-0.5, 0.5) plt.axis('off') plt.tight_layout() plt.show() # ================================================================= # Circuit 3: Simple Series Circuit # ================================================================= G3 = nx.Graph() G3.add_edge('start', 'C', resistance=4) G3.add_edge('C', 'end', resistance=6) pos3 = { 'start': (0, 0), 'C': (2, 0), 'end': (4, 0) } draw_circuit(G3, pos3, \"Circuit 3: Simple Series Circuit (4\u03a9 + 6\u03a9)\") # ================================================================= # Circuit 4: Single Resistor # ================================================================= G4 = nx.Graph() G4.add_edge('start', 'end', resistance=10) pos4 = { 'start': (0, 0), 'end': (2, 0) } draw_circuit(G4, pos4, \"Circuit 4: Single Resistor (10\u03a9)\") Summary Graph theory allows us to automatically simplify resistor networks , handle complex configurations , and is highly suited for software tools and educational simulations . Resources networkx documentation Circuit visualization tools Graph reduction algorithms","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction-and-motivation","text":"Calculating equivalent resistance is a fundamental task in circuit analysis. While traditional approaches use series and parallel simplification rules manually, graph theory provides a powerful alternative \u2014 transforming circuit analysis into an algorithmic graph simplification process. Circuits can be represented as graphs : - Nodes = junctions - Edges = resistors (with resistance as weight) By identifying series and parallel patterns in the graph, we can iteratively reduce it to compute total resistance between two terminals. This approach is: - Scalable for large networks - Automatable for software - Insightful for understanding electrical connectivity and topology","title":"Introduction and Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#learning-goals","text":"After completing this task, you should be able to: Represent a resistor network as a weighted graph. Apply reduction rules (series and parallel) using graph algorithms. Implement an algorithm that simplifies arbitrary configurations. Analyze different circuit structures programmatically.","title":"Learning Goals"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-connection","text":"Two resistors R\u2081 and R\u2082 in series: \\[ R_{eq} = R_1 + R_2 \\]","title":"Series Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-connection","text":"Two resistors R\u2081 and R\u2082 in parallel: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\quad \\Rightarrow \\quad R_{eq} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} \\]","title":"Parallel Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#implementation-in-python-with-networkx","text":"Below is a complete Python implementation and visualization of step-by-step circuit simplification using networkx .","title":"Implementation in Python with networkx"},{"location":"1%20Physics/5%20Circuits/Problem_1/#code","text":"import matplotlib.pyplot as plt import networkx as nx def draw_circuit(G, pos, title, highlight_paths=None): plt.figure(figsize=(10, 6)) node_colors = ['#4CAF50' if node in ['start', 'end'] else '#2196F3' for node in G.nodes()] # Draw nodes and edges nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=1800, edgecolors='black', linewidths=2) nx.draw_networkx_labels(G, pos, font_size=14, font_weight='bold') # Draw all edges first in black (thin) nx.draw_networkx_edges(G, pos, width=2, edge_color='black') # Draw highlighted edges on top (thicker) if highlight_paths: for i, path in enumerate(highlight_paths): color = ['#FF5722', '#3F51B5', '#009688'][i % 3] # Orange, Blue, Teal nx.draw_networkx_edges(G, pos, edgelist=path, edge_color=color, width=6, alpha=0.7) # Add resistance labels with white background for readability edge_labels = {(u, v): f\"{d['resistance']}\u03a9\" for u, v, d in G.edges(data=True)} nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=12, bbox=dict(facecolor='white', edgecolor='none', alpha=0.8, boxstyle='round,pad=0.3')) plt.title(title, fontsize=16, pad=20) plt.axis('off') plt.tight_layout() plt.show() # ================================================================= # Circuit 1: Complex Parallel-Series Combination # ================================================================= G1 = nx.Graph() G1.add_edge('start', 'A', resistance=4) G1.add_edge('A', 'C', resistance=2) G1.add_edge('start', 'B', resistance=8) G1.add_edge('B', 'C', resistance=4) G1.add_edge('C', 'end', resistance=6) pos1 = { 'start': (0, 0), 'A': (1, 1), 'B': (1, -1), 'C': (2, 0), 'end': (3, 0) } draw_circuit(G1, pos1, \"Circuit 1: Parallel Paths (start-A-C and start-B-C)\", highlight_paths=[ [('start', 'A'), ('A', 'C')], # Orange path [('start', 'B'), ('B', 'C')] # Blue path ]) # ================================================================= # Circuit 2: Pure Parallel Configuration (Fixed Version) # ================================================================= plt.figure(figsize=(10, 6)) G2 = nx.MultiGraph() pos2 = { 'start': (0, 0), 'C': (3, 0), 'end': (6, 0) } # Add edges G2.add_edge('start', 'C', resistance=6) G2.add_edge('start', 'C', resistance=12) G2.add_edge('C', 'end', resistance=6) # Draw nodes nx.draw_networkx_nodes(G2, pos2, node_size=1800, node_color=['#4CAF50', '#2196F3', '#4CAF50']) nx.draw_networkx_labels(G2, pos2, font_size=14, font_weight='bold') # Draw edges with clear labeling # First parallel resistor (6\u03a9) nx.draw_networkx_edges(G2, pos2, edgelist=[('start', 'C')], edge_color='#FF5722', width=4, connectionstyle=\"arc3,rad=0.15\") # Label for first parallel resistor plt.text(1.5, 0.25, \"6\u03a9\", ha='center', va='center', fontsize=12, color='black', bbox=dict(facecolor='white', alpha=1, boxstyle='round,pad=0.3')) # Second parallel resistor (12\u03a9) nx.draw_networkx_edges(G2, pos2, edgelist=[('start', 'C')], edge_color='#3F51B5', width=4, connectionstyle=\"arc3,rad=-0.15\") # Label for second parallel resistor plt.text(1.5, -0.25, \"12\u03a9\", ha='center', va='center', fontsize=12, color='black', bbox=dict(facecolor='white', alpha=1, boxstyle='round,pad=0.3')) # Series resistor (6\u03a9) nx.draw_networkx_edges(G2, pos2, edgelist=[('C', 'end')], width=3) plt.text(4.5, 0, \"6\u03a9\", ha='center', va='center', fontsize=12, color='black', bbox=dict(facecolor='white', alpha=1, boxstyle='round,pad=0.3')) plt.title(\"Circuit 2: Parallel Configuration (6\u03a9 || 12\u03a9)\", fontsize=16, pad=20) plt.xlim(-0.5, 6.5) plt.ylim(-0.5, 0.5) plt.axis('off') plt.tight_layout() plt.show() # ================================================================= # Circuit 3: Simple Series Circuit # ================================================================= G3 = nx.Graph() G3.add_edge('start', 'C', resistance=4) G3.add_edge('C', 'end', resistance=6) pos3 = { 'start': (0, 0), 'C': (2, 0), 'end': (4, 0) } draw_circuit(G3, pos3, \"Circuit 3: Simple Series Circuit (4\u03a9 + 6\u03a9)\") # ================================================================= # Circuit 4: Single Resistor # ================================================================= G4 = nx.Graph() G4.add_edge('start', 'end', resistance=10) pos4 = { 'start': (0, 0), 'end': (2, 0) } draw_circuit(G4, pos4, \"Circuit 4: Single Resistor (10\u03a9)\")","title":"code"},{"location":"1%20Physics/5%20Circuits/Problem_1/#summary","text":"Graph theory allows us to automatically simplify resistor networks , handle complex configurations , and is highly suited for software tools and educational simulations .","title":"Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#resources","text":"networkx documentation Circuit visualization tools Graph reduction algorithms","title":"Resources"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 \ud83d\udcca Exploring the Central Limit Theorem Through Simulations \ud83d\udccc Motivation The Central Limit Theorem (CLT) is a cornerstone of statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases \u2014 regardless of the population\u2019s original distribution. Simulations help visualize and understand this concept in an intuitive way. \ud83c\udfaf Problem Overview Objective Use Python simulations to explore how sample means from various population distributions approach a normal distribution as sample size increases. \ud83e\uddea Tasks 1. Simulating Sampling Distributions Select different population distributions to simulate: Uniform distribution Exponential distribution Binomial distribution For each, generate a large dataset representing the population (e.g., 100,000 values). 2. Sampling and Visualization Randomly draw samples of varying sizes (e.g., n = 5, 10, 30, 50 ) from the population. Calculate the sample mean for each draw. Repeat the process (e.g., 1,000 times) to build a sampling distribution . Plot histograms of these sample means and observe their shapes. 3. Parameter Exploration Explore the following: How the original distribution\u2019s shape affects the rate of convergence to normality. How sample size influences convergence. The effect of population variance on the spread of the sampling distribution. 4. Real-World Applications Understand the significance of CLT in practical scenarios: Estimating population parameters from samples Quality control and process monitoring Financial modeling and risk assessment \ud83e\uddea Simulation Details We simulate data from the following population distributions: Uniform distribution Exponential distribution Binomial distribution For each distribution: A population of 100,000 values is generated Samples of sizes n = 5, 10, 30, 50 are drawn repeatedly (1,000 times) Sample means are calculated and plotted as histograms \ud83d\udcbb Python Code import numpy as np import matplotlib.pyplot as plt import seaborn as sns def generate_population(dist, size=100_000, **kwargs): if dist == 'uniform': return np.random.uniform(kwargs.get('low', 0), kwargs.get('high', 1), size) if dist == 'exponential': return np.random.exponential(kwargs.get('scale', 1.0), size) if dist == 'binomial': return np.random.binomial(kwargs.get('n', 10), kwargs.get('p', 0.5), size) raise ValueError(f\"Unknown distribution: {dist}\") def sample_means(pop, sample_size, n_samples=1000): return [np.mean(np.random.choice(pop, sample_size, replace=False)) for _ in range(n_samples)] def plot_sampling_dists(populations, sample_sizes, n_samples=1000, bins=30): for name, pop in populations.items(): plt.figure(figsize=(12, 8)) for i, n in enumerate(sample_sizes, 1): means = sample_means(pop, n, n_samples) plt.subplot(2, 2, i) sns.histplot(means, kde=True, bins=bins) plt.title(f\"{name.title()} (n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": dists = { 'uniform': {'low': 0, 'high': 1}, 'exponential':{'scale': 2.0}, 'binomial': {'n': 10, 'p': 0.3}, } pops = {name: generate_population(name, **params) for name, params in dists.items()} sizes = [5, 10, 30, 50] plot_sampling_dists(pops, sizes) \ud83d\udccc Output The script generates a set of plots for each distribution. Each plot shows how the distribution of sample means changes as the sample size increases \u2014 illustrating the Central Limit Theorem in action.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"\ud83d\udcca Exploring the Central Limit Theorem Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a cornerstone of statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases \u2014 regardless of the population\u2019s original distribution. Simulations help visualize and understand this concept in an intuitive way.","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-overview","text":"","title":"\ud83c\udfaf Problem Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"Use Python simulations to explore how sample means from various population distributions approach a normal distribution as sample size increases.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#tasks","text":"","title":"\ud83e\uddea Tasks"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"Select different population distributions to simulate: Uniform distribution Exponential distribution Binomial distribution For each, generate a large dataset representing the population (e.g., 100,000 values).","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"Randomly draw samples of varying sizes (e.g., n = 5, 10, 30, 50 ) from the population. Calculate the sample mean for each draw. Repeat the process (e.g., 1,000 times) to build a sampling distribution . Plot histograms of these sample means and observe their shapes.","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"Explore the following: How the original distribution\u2019s shape affects the rate of convergence to normality. How sample size influences convergence. The effect of population variance on the spread of the sampling distribution.","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-real-world-applications","text":"Understand the significance of CLT in practical scenarios: Estimating population parameters from samples Quality control and process monitoring Financial modeling and risk assessment","title":"4. Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-details","text":"We simulate data from the following population distributions: Uniform distribution Exponential distribution Binomial distribution For each distribution: A population of 100,000 values is generated Samples of sizes n = 5, 10, 30, 50 are drawn repeatedly (1,000 times) Sample means are calculated and plotted as histograms","title":"\ud83e\uddea Simulation Details"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns def generate_population(dist, size=100_000, **kwargs): if dist == 'uniform': return np.random.uniform(kwargs.get('low', 0), kwargs.get('high', 1), size) if dist == 'exponential': return np.random.exponential(kwargs.get('scale', 1.0), size) if dist == 'binomial': return np.random.binomial(kwargs.get('n', 10), kwargs.get('p', 0.5), size) raise ValueError(f\"Unknown distribution: {dist}\") def sample_means(pop, sample_size, n_samples=1000): return [np.mean(np.random.choice(pop, sample_size, replace=False)) for _ in range(n_samples)] def plot_sampling_dists(populations, sample_sizes, n_samples=1000, bins=30): for name, pop in populations.items(): plt.figure(figsize=(12, 8)) for i, n in enumerate(sample_sizes, 1): means = sample_means(pop, n, n_samples) plt.subplot(2, 2, i) sns.histplot(means, kde=True, bins=bins) plt.title(f\"{name.title()} (n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": dists = { 'uniform': {'low': 0, 'high': 1}, 'exponential':{'scale': 2.0}, 'binomial': {'n': 10, 'p': 0.3}, } pops = {name: generate_population(name, **params) for name, params in dists.items()} sizes = [5, 10, 30, 50] plot_sampling_dists(pops, sizes)","title":"\ud83d\udcbb Python Code"},{"location":"1%20Physics/6%20Statistics/Problem_1/#output","text":"The script generates a set of plots for each distribution. Each plot shows how the distribution of sample means changes as the sample size increases \u2014 illustrating the Central Limit Theorem in action.","title":"\ud83d\udccc Output"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 \ud83c\udfb2 Estimating \u03c0 Using Monte Carlo Methods \ud83d\udccc Introduction Monte Carlo simulations are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. One elegant and accessible application is estimating the value of \u03c0 through probability and geometry. This project explores two Monte Carlo techniques for estimating \u03c0: Using random points inside a square and circle Using Buffon\u2019s Needle experiment These simulations provide visual insight into the relationship between randomness and mathematical constants. \ud83e\udde0 Method 1: Monte Carlo Estimation with Random Points \ud83d\udd0d Concept Imagine a square with a circle inscribed inside it. If you randomly generate points in the square, the proportion of points that fall inside the circle is related to \u03c0. Let: - The square be of size 2\u00d72 (centered at the origin) - The circle have a radius of 1 Then the area ratio is: \u03c0 \u2248 4 \u00d7 (points inside circle / total points) As the number of points increases, this ratio converges to \u03c0. \ud83d\udcd0 Method 2: Buffon\u2019s Needle Experiment \ud83d\udd0d Concept Buffon\u2019s Needle is a classic probability problem where a needle of length L is dropped on a floor with parallel lines spaced D units apart. The probability P that the needle crosses a line is related to \u03c0 by: \u03c0 \u2248 (2 \u00d7 L \u00d7 number of throws) / (D \u00d7 number of crossings) This method uses randomness and geometry to estimate \u03c0 through repeated trials. \ud83d\udcbb Python Implementation Below is the complete Python code to simulate both methods, visualize results, and compare their convergence: import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points=10000, visualize=True): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points if visualize: plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, color='green', label='Inside Circle') plt.scatter(x[~inside], y[~inside], s=1, color='red', label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False) plt.gca().add_artist(circle) plt.title(f'\u03c0 Estimate (Circle Method): {pi_estimate:.5f} (n={n_points})') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.legend() plt.grid(True) plt.tight_layout() plt.show() return pi_estimate def estimate_pi_buffon(n_drops=100000, needle_length=1.0, line_spacing=2.0, visualize=True): if needle_length > line_spacing: raise ValueError(\"Needle length must be \u2264 distance between lines.\") x_center = np.random.uniform(0, line_spacing / 2, n_drops) theta = np.random.uniform(0, np.pi / 2, n_drops) crosses = x_center <= (needle_length / 2) * np.sin(theta) crossings = np.sum(crosses) if crossings == 0: return np.nan pi_estimate = (2 * needle_length * n_drops) / (line_spacing * crossings) if visualize: plt.figure(figsize=(12, 5)) sample = 1000 # Visualize only 1000 for performance for _ in range(sample): x0 = np.random.uniform(0, line_spacing * 5) y0 = np.random.uniform(0, 10) angle = np.random.uniform(0, np.pi) x1 = x0 + (needle_length / 2) * np.cos(angle) y1 = y0 + (needle_length / 2) * np.sin(angle) x2 = x0 - (needle_length / 2) * np.cos(angle) y2 = y0 - (needle_length / 2) * np.sin(angle) plt.plot([x1, x2], [y1, y2], 'b-', alpha=0.2) for i in range(6): plt.axvline(x=i * line_spacing, color='black', linestyle='--') plt.title(f\"Buffon's Needle Simulation (100,000 Needles)\\n\u03c0 Estimate: {pi_estimate:.5f}\") plt.axis('equal') plt.grid(True) plt.tight_layout() plt.show() return pi_estimate def convergence_analysis(): trials = [10, 100, 1000, 5000, 10000, 50000, 100000] estimates_circle = [estimate_pi_circle(n, visualize=False) for n in trials] estimates_buffon = [estimate_pi_buffon(n, visualize=False) for n in trials] plt.figure(figsize=(10, 5)) plt.plot(trials, estimates_circle, label=\"Circle Method\", marker='o') plt.plot(trials, estimates_buffon, label=\"Buffon's Needle\", marker='s') plt.axhline(np.pi, color='gray', linestyle='--', label='True \u03c0') for x, y in zip(trials, estimates_circle): plt.text(x, y + 0.05, f\"{y:.4f}\", fontsize=8, ha='center', color='green') for x, y in zip(trials, estimates_buffon): plt.text(x, y - 0.1, f\"{y:.4f}\", fontsize=8, ha='center', color='blue') plt.xscale(\"log\") plt.xlabel(\"Number of Simulations (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimation Methods\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": print(\"Estimating \u03c0 using Circle Method:\") pi_circle = estimate_pi_circle(10000) print(\"\\nEstimating \u03c0 using Buffon's Needle Method:\") pi_buffon = estimate_pi_buffon(100000) print(\"\\nRunning Convergence Analysis:\") convergence_analysis() \ud83d\udcca Analysis Method Description Convergence Visual Insight Circle Method Geometric simulation inside square Fast Clear and intuitive Buffon\u2019s Needle Needle drops over parallel lines Slower More complex Both methods demonstrate the power of randomness in numerical computation. The circle method is simpler and converges faster, while Buffon's Needle offers historical context and insight into geometric probability. \ud83d\udcda References Monte Carlo Method \u2013 Wikipedia Buffon\u2019s Needle Problem \u2013 Wikipedia","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"\ud83c\udfb2 Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#introduction","text":"Monte Carlo simulations are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. One elegant and accessible application is estimating the value of \u03c0 through probability and geometry. This project explores two Monte Carlo techniques for estimating \u03c0: Using random points inside a square and circle Using Buffon\u2019s Needle experiment These simulations provide visual insight into the relationship between randomness and mathematical constants.","title":"\ud83d\udccc Introduction"},{"location":"1%20Physics/6%20Statistics/Problem_2/#method-1-monte-carlo-estimation-with-random-points","text":"","title":"\ud83e\udde0 Method 1: Monte Carlo Estimation with Random Points"},{"location":"1%20Physics/6%20Statistics/Problem_2/#concept","text":"Imagine a square with a circle inscribed inside it. If you randomly generate points in the square, the proportion of points that fall inside the circle is related to \u03c0. Let: - The square be of size 2\u00d72 (centered at the origin) - The circle have a radius of 1 Then the area ratio is: \u03c0 \u2248 4 \u00d7 (points inside circle / total points) As the number of points increases, this ratio converges to \u03c0.","title":"\ud83d\udd0d Concept"},{"location":"1%20Physics/6%20Statistics/Problem_2/#method-2-buffons-needle-experiment","text":"","title":"\ud83d\udcd0 Method 2: Buffon\u2019s Needle Experiment"},{"location":"1%20Physics/6%20Statistics/Problem_2/#concept_1","text":"Buffon\u2019s Needle is a classic probability problem where a needle of length L is dropped on a floor with parallel lines spaced D units apart. The probability P that the needle crosses a line is related to \u03c0 by: \u03c0 \u2248 (2 \u00d7 L \u00d7 number of throws) / (D \u00d7 number of crossings) This method uses randomness and geometry to estimate \u03c0 through repeated trials.","title":"\ud83d\udd0d Concept"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-implementation","text":"Below is the complete Python code to simulate both methods, visualize results, and compare their convergence: import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points=10000, visualize=True): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points if visualize: plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, color='green', label='Inside Circle') plt.scatter(x[~inside], y[~inside], s=1, color='red', label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False) plt.gca().add_artist(circle) plt.title(f'\u03c0 Estimate (Circle Method): {pi_estimate:.5f} (n={n_points})') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.legend() plt.grid(True) plt.tight_layout() plt.show() return pi_estimate def estimate_pi_buffon(n_drops=100000, needle_length=1.0, line_spacing=2.0, visualize=True): if needle_length > line_spacing: raise ValueError(\"Needle length must be \u2264 distance between lines.\") x_center = np.random.uniform(0, line_spacing / 2, n_drops) theta = np.random.uniform(0, np.pi / 2, n_drops) crosses = x_center <= (needle_length / 2) * np.sin(theta) crossings = np.sum(crosses) if crossings == 0: return np.nan pi_estimate = (2 * needle_length * n_drops) / (line_spacing * crossings) if visualize: plt.figure(figsize=(12, 5)) sample = 1000 # Visualize only 1000 for performance for _ in range(sample): x0 = np.random.uniform(0, line_spacing * 5) y0 = np.random.uniform(0, 10) angle = np.random.uniform(0, np.pi) x1 = x0 + (needle_length / 2) * np.cos(angle) y1 = y0 + (needle_length / 2) * np.sin(angle) x2 = x0 - (needle_length / 2) * np.cos(angle) y2 = y0 - (needle_length / 2) * np.sin(angle) plt.plot([x1, x2], [y1, y2], 'b-', alpha=0.2) for i in range(6): plt.axvline(x=i * line_spacing, color='black', linestyle='--') plt.title(f\"Buffon's Needle Simulation (100,000 Needles)\\n\u03c0 Estimate: {pi_estimate:.5f}\") plt.axis('equal') plt.grid(True) plt.tight_layout() plt.show() return pi_estimate def convergence_analysis(): trials = [10, 100, 1000, 5000, 10000, 50000, 100000] estimates_circle = [estimate_pi_circle(n, visualize=False) for n in trials] estimates_buffon = [estimate_pi_buffon(n, visualize=False) for n in trials] plt.figure(figsize=(10, 5)) plt.plot(trials, estimates_circle, label=\"Circle Method\", marker='o') plt.plot(trials, estimates_buffon, label=\"Buffon's Needle\", marker='s') plt.axhline(np.pi, color='gray', linestyle='--', label='True \u03c0') for x, y in zip(trials, estimates_circle): plt.text(x, y + 0.05, f\"{y:.4f}\", fontsize=8, ha='center', color='green') for x, y in zip(trials, estimates_buffon): plt.text(x, y - 0.1, f\"{y:.4f}\", fontsize=8, ha='center', color='blue') plt.xscale(\"log\") plt.xlabel(\"Number of Simulations (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimation Methods\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": print(\"Estimating \u03c0 using Circle Method:\") pi_circle = estimate_pi_circle(10000) print(\"\\nEstimating \u03c0 using Buffon's Needle Method:\") pi_buffon = estimate_pi_buffon(100000) print(\"\\nRunning Convergence Analysis:\") convergence_analysis()","title":"\ud83d\udcbb Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis","text":"Method Description Convergence Visual Insight Circle Method Geometric simulation inside square Fast Clear and intuitive Buffon\u2019s Needle Needle drops over parallel lines Slower More complex Both methods demonstrate the power of randomness in numerical computation. The circle method is simpler and converges faster, while Buffon's Needle offers historical context and insight into geometric probability.","title":"\ud83d\udcca Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#references","text":"Monte Carlo Method \u2013 Wikipedia Buffon\u2019s Needle Problem \u2013 Wikipedia","title":"\ud83d\udcda References"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 \ud83c\udf0d Measuring Earth's Gravitational Acceleration with a Pendulum \ud83d\udccc Motivation The acceleration due to gravity, g , is a fundamental constant in physics. Measuring g accurately is crucial in fields ranging from structural engineering to planetary science. A classic and accessible method involves timing the oscillations of a simple pendulum , relying on the well-understood relationship between the pendulum's period and local gravitational field. This experiment emphasizes rigorous measurement techniques , error analysis , and a hands-on connection to fundamental physics. \ud83e\uddea Objective Estimate the gravitational acceleration g by measuring the period of a simple pendulum and performing a full uncertainty analysis. Background Theory The motion of a simple pendulum (for small angles \\(\\theta < 15^\\circ\\) ) is described by the equation: \\(T = 2\\pi \\sqrt{\\frac{L}{g}}\\) Where: - \\(T\\) is the period of one oscillation (in seconds) - \\(L\\) is the length of the pendulum (in meters) - \\(g\\) is the acceleration due to gravity (in m/s\u00b2) Rearranged to solve for \\(g\\) : \\(g = \\frac{4\\pi^2 L}{T^2}\\) \ud83e\uddf0 Materials String: 0.8 meters long Mass: e.g., bag of coins, metal washer, small weight Ruler or measuring tape Stopwatch or smartphone timer Fixed support (e.g., hook, rod, table edge) \ud83d\udee0\ufe0f Procedure 1. Setup Construct the pendulum by tying the weight securely to one end of the string. Fix the other end to a support so that the pendulum can swing freely. Measure the length of the pendulum from the point of suspension to the center of mass of the weight. Notation: Let \\(L\\) be the length of the pendulum (in meters) in our case it is 0.8m Ruler measure resolution = 1 mm Although the ruler resolution is 1 mm, due to observation limits, we consider an effective resolution of 2 mm. Therefore, Let \\(\u0394L = (\\text{resolution of measuring tool}) / 2 = 0.001\\) m 2. Data Collection Displace the pendulum by less than 15\u00b0 and release it. Use a stopwatch to time 10 full oscillations . Repeat this process 10 times to reduce random error. \ud83d\udcca Sample Data Table Trial Time for 10 Oscillations (T\u2081\u2080) [s] 1 17.86 2 17.95 3 17.92 4 17.88 5 17.93 6 17.84 7 17.95 8 17.71 9 17.92 10 17.99 \ud83d\udcd0 Calculations \u2705 Mean time for 10 oscillations: \\(\\overline{T_{10}} = 17.895\\) s \u2705 Standard deviation: \\(\\sigma_T = 0.078\\) s \u2705 Uncertainty in \\(\\overline{T_{10}}\\) : \\(\\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{10}} = 0.025\\) s \u2705 Period of one oscillation: \\(T = \\frac{17.895}{10} = 1.7895\\) s \u2705 Uncertainty in \\(T\\) : \\(\\Delta T = \\frac{0.025}{10} = 0.0025\\) s \u2705 Calculated gravitational acceleration: \\(g = \\frac{4\\pi^2 \\cdot 0.800}{(1.7895)^2} = 9.862\\) m/s\u00b2 \ud83d\udcc9 Uncertainty in \\(g\\) Relative uncertainty: \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\cdot \\frac{\\Delta T}{T}\\right)^2} = \\sqrt{(0.00125)^2 + (0.0028)^2} = 0.0031\\) Absolute uncertainty: \\(\\Delta g = 0.0031 \\cdot 9.862 = 0.030\\) m/s\u00b2 \u2705 Final Result \\(g = 9.862 \\pm 0.030 \\ \\text{m/s}^2\\) \ud83d\udcc8 Analysis \u2705 Comparison Standard gravitational acceleration: 9.81 m/s\u00b2 Measured value: 9.862 \u00b1 0.030 m/s\u00b2 \ud83e\uddfe Discussion Uncertainty in Length (\u0394L): Originates from ruler resolution; using a better tool would improve accuracy. Uncertainty in Timing (\u0394T): Human reaction time introduces variability. Using automated timing improves reliability. Repeating measurements 10 times helps reduce random error in T . Assumptions: Small-angle approximation (<15\u00b0) Air resistance and friction at pivot are negligible Rigid, massless string import numpy as np import matplotlib.pyplot as plt # Updated pendulum data (corrected 8th value from 17.99 to 17.71) T10_measurements = np.array([17.86, 17.95, 17.92, 17.88, 17.93, 17.84, 17.95, 17.71, 17.92, 17.99]) L = 0.800 delta_L = 0.001 # 2mm resolution \u2192 \u0394L = 0.001 m # Mean and standard deviation T10_mean = np.mean(T10_measurements) T10_std = np.std(T10_measurements, ddof=1) delta_T10 = T10_std / np.sqrt(len(T10_measurements)) # Period and uncertainty T = T10_mean / 10 delta_T = delta_T10 / 10 # Gravitational acceleration g = (4 * np.pi**2 * L) / T**2 # Uncertainty in g rel_uncertainty = np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) delta_g = g * rel_uncertainty # Print results print(f\"Mean time for 10 oscillations (T10): {T10_mean:.3f} \u00b1 {delta_T10:.3f} s\") print(f\"Period (T): {T:.4f} \u00b1 {delta_T:.4f} s\") print(f\"Calculated g: {g:.3f} \u00b1 {delta_g:.3f} m/s\u00b2\") # Plot 1: T10 measurements plt.figure(figsize=(8, 4)) plt.plot(T10_measurements, 'o-', label='Measurements') plt.axhline(y=T10_mean, color='red', linestyle='--', label=f'Mean = {T10_mean:.2f} s') plt.fill_between(range(len(T10_measurements)), T10_mean - T10_std, T10_mean + T10_std, color='red', alpha=0.1, label='\u00b11\u03c3') plt.title(\"Time for 10 Oscillations\") plt.xlabel(\"Trial\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Plot 2: Convergence of g estimation g_estimates = (4 * np.pi**2 * L) / (T10_measurements / 10)**2 plt.figure(figsize=(8, 4)) plt.plot(g_estimates, 'o-', label='g estimates per trial') plt.axhline(y=g, color='green', linestyle='--', label=f'Average g = {g:.3f} m/s\u00b2') plt.axhline(y=9.81, color='black', linestyle=':', label='Standard g = 9.81 m/s\u00b2') plt.title(\"Estimation of g Over Trials\") plt.xlabel(\"Trial\") plt.ylabel(\"g (m/s\u00b2)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Plot 3: Final g estimate with uncertainty plt.figure(figsize=(6, 5)) plt.errorbar(1, g, yerr=delta_g, fmt='o', color='blue', capsize=5, label=f'Measured g = {g:.3f} \u00b1 {delta_g:.3f}') plt.axhline(y=9.81, color='black', linestyle=':', label='Standard g = 9.81 m/s\u00b2') plt.xlim(0, 2) plt.xticks([]) plt.ylabel(\"g (m/s\u00b2)\") plt.title(\"Final Measurement with Uncertainty\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() \ud83d\udcdd Conclusion This experiment provides a clear, practical method to determine gravitational acceleration using a pendulum. Repeating measurements and analyzing uncertainty with statistical tools improves reliability and strengthens understanding of physical principles and error propagation. \ud83e\uddfe Comparison Standard gravitational acceleration: 9.81 m/s\u00b2 Measured value: 9.862 \u00b1 0.030 m/s\u00b2 \u2705 The result is consistent with the accepted value within the margin of uncertainty.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"\ud83c\udf0d Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity, g , is a fundamental constant in physics. Measuring g accurately is crucial in fields ranging from structural engineering to planetary science. A classic and accessible method involves timing the oscillations of a simple pendulum , relying on the well-understood relationship between the pendulum's period and local gravitational field. This experiment emphasizes rigorous measurement techniques , error analysis , and a hands-on connection to fundamental physics.","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"Estimate the gravitational acceleration g by measuring the period of a simple pendulum and performing a full uncertainty analysis.","title":"\ud83e\uddea Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#background-theory","text":"The motion of a simple pendulum (for small angles \\(\\theta < 15^\\circ\\) ) is described by the equation: \\(T = 2\\pi \\sqrt{\\frac{L}{g}}\\) Where: - \\(T\\) is the period of one oscillation (in seconds) - \\(L\\) is the length of the pendulum (in meters) - \\(g\\) is the acceleration due to gravity (in m/s\u00b2) Rearranged to solve for \\(g\\) : \\(g = \\frac{4\\pi^2 L}{T^2}\\)","title":"Background Theory"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"String: 0.8 meters long Mass: e.g., bag of coins, metal washer, small weight Ruler or measuring tape Stopwatch or smartphone timer Fixed support (e.g., hook, rod, table edge)","title":"\ud83e\uddf0 Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"\ud83d\udee0\ufe0f Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-setup","text":"Construct the pendulum by tying the weight securely to one end of the string. Fix the other end to a support so that the pendulum can swing freely. Measure the length of the pendulum from the point of suspension to the center of mass of the weight. Notation: Let \\(L\\) be the length of the pendulum (in meters) in our case it is 0.8m Ruler measure resolution = 1 mm Although the ruler resolution is 1 mm, due to observation limits, we consider an effective resolution of 2 mm. Therefore, Let \\(\u0394L = (\\text{resolution of measuring tool}) / 2 = 0.001\\) m","title":"1. Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-data-collection","text":"Displace the pendulum by less than 15\u00b0 and release it. Use a stopwatch to time 10 full oscillations . Repeat this process 10 times to reduce random error.","title":"2. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#sample-data-table","text":"Trial Time for 10 Oscillations (T\u2081\u2080) [s] 1 17.86 2 17.95 3 17.92 4 17.88 5 17.93 6 17.84 7 17.95 8 17.71 9 17.92 10 17.99","title":"\ud83d\udcca Sample Data Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"\ud83d\udcd0 Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#mean-time-for-10-oscillations","text":"\\(\\overline{T_{10}} = 17.895\\) s","title":"\u2705 Mean time for 10 oscillations:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#standard-deviation","text":"\\(\\sigma_T = 0.078\\) s","title":"\u2705 Standard deviation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-overlinet_10","text":"\\(\\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{10}} = 0.025\\) s","title":"\u2705 Uncertainty in \\(\\overline{T_{10}}\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#period-of-one-oscillation","text":"\\(T = \\frac{17.895}{10} = 1.7895\\) s","title":"\u2705 Period of one oscillation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-t","text":"\\(\\Delta T = \\frac{0.025}{10} = 0.0025\\) s","title":"\u2705 Uncertainty in \\(T\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculated-gravitational-acceleration","text":"\\(g = \\frac{4\\pi^2 \\cdot 0.800}{(1.7895)^2} = 9.862\\) m/s\u00b2","title":"\u2705 Calculated gravitational acceleration:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-g","text":"Relative uncertainty: \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\cdot \\frac{\\Delta T}{T}\\right)^2} = \\sqrt{(0.00125)^2 + (0.0028)^2} = 0.0031\\) Absolute uncertainty: \\(\\Delta g = 0.0031 \\cdot 9.862 = 0.030\\) m/s\u00b2","title":"\ud83d\udcc9 Uncertainty in \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-result","text":"\\(g = 9.862 \\pm 0.030 \\ \\text{m/s}^2\\)","title":"\u2705 Final Result"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"\ud83d\udcc8 Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#comparison","text":"Standard gravitational acceleration: 9.81 m/s\u00b2 Measured value: 9.862 \u00b1 0.030 m/s\u00b2","title":"\u2705 Comparison"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"Uncertainty in Length (\u0394L): Originates from ruler resolution; using a better tool would improve accuracy. Uncertainty in Timing (\u0394T): Human reaction time introduces variability. Using automated timing improves reliability. Repeating measurements 10 times helps reduce random error in T . Assumptions: Small-angle approximation (<15\u00b0) Air resistance and friction at pivot are negligible Rigid, massless string import numpy as np import matplotlib.pyplot as plt # Updated pendulum data (corrected 8th value from 17.99 to 17.71) T10_measurements = np.array([17.86, 17.95, 17.92, 17.88, 17.93, 17.84, 17.95, 17.71, 17.92, 17.99]) L = 0.800 delta_L = 0.001 # 2mm resolution \u2192 \u0394L = 0.001 m # Mean and standard deviation T10_mean = np.mean(T10_measurements) T10_std = np.std(T10_measurements, ddof=1) delta_T10 = T10_std / np.sqrt(len(T10_measurements)) # Period and uncertainty T = T10_mean / 10 delta_T = delta_T10 / 10 # Gravitational acceleration g = (4 * np.pi**2 * L) / T**2 # Uncertainty in g rel_uncertainty = np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) delta_g = g * rel_uncertainty # Print results print(f\"Mean time for 10 oscillations (T10): {T10_mean:.3f} \u00b1 {delta_T10:.3f} s\") print(f\"Period (T): {T:.4f} \u00b1 {delta_T:.4f} s\") print(f\"Calculated g: {g:.3f} \u00b1 {delta_g:.3f} m/s\u00b2\") # Plot 1: T10 measurements plt.figure(figsize=(8, 4)) plt.plot(T10_measurements, 'o-', label='Measurements') plt.axhline(y=T10_mean, color='red', linestyle='--', label=f'Mean = {T10_mean:.2f} s') plt.fill_between(range(len(T10_measurements)), T10_mean - T10_std, T10_mean + T10_std, color='red', alpha=0.1, label='\u00b11\u03c3') plt.title(\"Time for 10 Oscillations\") plt.xlabel(\"Trial\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Plot 2: Convergence of g estimation g_estimates = (4 * np.pi**2 * L) / (T10_measurements / 10)**2 plt.figure(figsize=(8, 4)) plt.plot(g_estimates, 'o-', label='g estimates per trial') plt.axhline(y=g, color='green', linestyle='--', label=f'Average g = {g:.3f} m/s\u00b2') plt.axhline(y=9.81, color='black', linestyle=':', label='Standard g = 9.81 m/s\u00b2') plt.title(\"Estimation of g Over Trials\") plt.xlabel(\"Trial\") plt.ylabel(\"g (m/s\u00b2)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Plot 3: Final g estimate with uncertainty plt.figure(figsize=(6, 5)) plt.errorbar(1, g, yerr=delta_g, fmt='o', color='blue', capsize=5, label=f'Measured g = {g:.3f} \u00b1 {delta_g:.3f}') plt.axhline(y=9.81, color='black', linestyle=':', label='Standard g = 9.81 m/s\u00b2') plt.xlim(0, 2) plt.xticks([]) plt.ylabel(\"g (m/s\u00b2)\") plt.title(\"Final Measurement with Uncertainty\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83e\uddfe Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"This experiment provides a clear, practical method to determine gravitational acceleration using a pendulum. Repeating measurements and analyzing uncertainty with statistical tools improves reliability and strengthens understanding of physical principles and error propagation.","title":"\ud83d\udcdd Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#comparison_1","text":"Standard gravitational acceleration: 9.81 m/s\u00b2 Measured value: 9.862 \u00b1 0.030 m/s\u00b2 \u2705 The result is consistent with the accepted value within the margin of uncertainty.","title":"\ud83e\uddfe Comparison"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}